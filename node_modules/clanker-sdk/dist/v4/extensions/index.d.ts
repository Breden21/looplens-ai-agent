import { C as ClankerTransactionConfig, e as ClankerAirdrop_v4_abi, d as ClankerResult } from '../../write-clanker-contracts-B573YCMc.js';
import { MerkleTree } from '@openzeppelin/merkle-tree/dist/merkletree.js';
import * as z from 'zod/v4';
import { C as Chain } from '../../clankerTokenV4-CGt2_r4R.js';
import { Clanker } from '../index.js';
import 'viem';
import '../../ClankerToken-Dra5lppJ.js';

declare const AirdropEntrySchema: z.ZodArray<z.ZodObject<{
    account: z.ZodCustom<`0x${string}`, `0x${string}`>;
    amount: z.ZodNumber;
}, z.core.$strip>>;
type AirdropRecipient = z.input<typeof AirdropEntrySchema>[0];
type MerkleEntry = [account: `0x${string}`, amount: string];
/**
 * Create an airdrop for the recipients.
 *
 * @param recipients Recipients recieving airdrop.
 * @param options.tokenDecimals Custom token decimals.
 * @returns Tree to save offline and Airdrop data for the smart contract.
 */
declare function createAirdrop(recipients: AirdropRecipient[], options?: {
    tokenDecimals: bigint;
}): {
    tree: MerkleTree<MerkleEntry>;
    airdrop: {
        merkleRoot: `0x${string}`;
        amount: number;
    };
};
/**
 * Register an airdrop merkle tree with the Clanker service.
 *
 * @dev Requires that the associated token is already deployed and indexed. The token
 * must also have the merkle root associated with it.
 *
 * @param token The token associated with the tree.
 * @param tree The tree to register.
 * @returns Success.
 */
declare function registerAirdrop(token: `0x${string}`, tree: MerkleTree<MerkleEntry>): Promise<boolean>;
/**
 * Get all proofs for an account given a merkle tree.
 *
 * @param tree The tree to check.
 * @param account The account to check for.
 * @returns All proofs and their associated entries for claiming.
 */
declare function getAirdropProofs(tree: MerkleTree<MerkleEntry>, account: `0x${string}`): {
    proofs: {
        proof: `0x${string}`[];
        entry: {
            account: `0x${string}`;
            amount: bigint;
        };
    }[];
};
/**
 * Get all proofs for an account given a token that has a merkle tree associated with it. The token and tree must have been registered with the Clanker service.
 *
 * @param token The token with the airdrop.
 * @param account The account to check for.
 * @returns All proofs and their associated entries for claiming.
 */
declare function fetchAirdropProofs(token: `0x${string}`, account: `0x${string}`): Promise<{
    proofs: {
        proof: `0x${string}`[];
        entry: {
            account: `0x${string}`;
            amount: bigint;
        };
    }[];
}>;
/**
 * Create a transaction to claim a specific airdrop for.
 *
 * @param token The token that did the airdrop
 * @param recipient The address recieving the airdrop
 * @param amount The amount registered in the airdrop. Note, this must be the exact registered amount.
 * @param proof Merkle proof for the address and amount (see `getProofs`)
 * @returns Arguments that can be used with a viem transaction.
 */
declare function getClaimAirdropTransaction({ token, recipient, amount, proof, chainId, }: {
    chainId: Chain;
    token: `0x${string}`;
    recipient: `0x${string}`;
    amount: bigint;
    proof: `0x${string}`[];
}): ClankerTransactionConfig<typeof ClankerAirdrop_v4_abi, 'claim'>;
/**
 * Claim an airdrop
 *
 * @param clanker Clanker object used for claiming
 * @param token The token that did the airdrop
 * @param recipient The address recieving the airdrop
 * @param amount The amount registered in the airdrop. Note, this must be the exact registered amount.
 * @param proof Merkle proof for the address and amount (see `getProofs`)
 * @returns Outcome of the transaction
 */
declare function claimAirdrop(data: {
    clanker: Clanker;
    token: `0x${string}`;
    recipient: `0x${string}`;
    amount: bigint;
    proof: `0x${string}`[];
}): ClankerResult<{
    txHash: `0x${string}`;
}>;

export { type AirdropRecipient, claimAirdrop, createAirdrop, fetchAirdropProofs, getAirdropProofs, getClaimAirdropTransaction, registerAirdrop };
