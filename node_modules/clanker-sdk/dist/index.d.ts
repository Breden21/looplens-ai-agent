export { C as ClankerTokenV3 } from './clankerTokenV3-BqHTF9QY.js';
import { C as Chain, a as ClankerTokenV4, b as ClankerDeployment } from './clankerTokenV4-CGt2_r4R.js';
export { d as CLANKERS, g as Chains, h as ClankerDeployments, f as Clankers, R as RelatedV3_1, c as RelatedV4, T as Type, i as clankerConfigFor } from './clankerTokenV4-CGt2_r4R.js';
import { ContractConstructorArgs } from 'viem';
import { C as ClankerToken_v3_1_abi, a as ClankerToken_v4_abi } from './ClankerToken-Dra5lppJ.js';
import { StandardMerkleTree } from '@openzeppelin/merkle-tree';
import 'zod/v4';

declare const DEGEN_ADDRESS: `0x${string}`;
declare const NATIVE_ADDRESS: `0x${string}`;
declare const CLANKER_ADDRESS: `0x${string}`;
declare const ANON_ADDRESS: `0x${string}`;
declare const HIGHER_ADDRESS: `0x${string}`;
declare const CB_BTC_ADDRESS: `0x${string}`;
declare const A0X_ADDRESS: `0x${string}`;
declare const WETH_ADDRESSES: Record<Chain, `0x${string}`>;
declare const DEFAULT_SUPPLY = 100000000000000000000000000000n;
declare enum PoolPositions {
    Standard = "Standard",
    Project = "Project"
}
type PoolPosition = {
    tickLower: number;
    tickUpper: number;
    positionBps: number;
};
declare const POOL_POSITIONS: Record<PoolPositions, PoolPosition[]>;
declare enum FeeConfigs {
    DynamicBasic = "DynamicBasic",
    StaticBasic = "StaticBasic",
    Dynamic3 = "Dynamic3"
}
declare const FEE_CONFIGS: Record<FeeConfigs, Required<ClankerTokenV4['fees']>>;

declare const findVanityAddress: (args: ContractConstructorArgs<typeof ClankerToken_v3_1_abi>, admin: `0x${string}`, suffix?: `0x${string}`, options?: {
    chainId?: number;
}) => Promise<{
    salt: `0x${string}`;
    token: `0x${string}`;
}>;
declare const findVanityAddressV4: (args: ContractConstructorArgs<typeof ClankerToken_v4_abi>, admin: `0x${string}`, suffix: `0x${string}` | undefined, config: ClankerDeployment) => Promise<{
    salt: `0x${string}`;
    token: `0x${string}`;
}>;

/**
 * Calculate starting tick and spacing for a token pooled against ETH.
 *
 * @param marketCap Target market cap for the token
 * @returns Tick information for the pool
 */
declare const getTickFromMarketCap: (marketCap: number) => {
    pairedToken: "WETH";
    tickIfToken0IsClanker: number;
    tickSpacing: number;
};

interface AirdropEntry {
    account: `0x${string}`;
    amount: number;
}
declare function createMerkleTree(entries: AirdropEntry[]): {
    tree: StandardMerkleTree<[string, string]>;
    root: `0x${string}`;
    entries: [string, string][];
};
declare function getMerkleProof(tree: StandardMerkleTree<[string, string]>, entries: [string, string][], account: `0x${string}`, amount: number): `0x${string}`[];
declare function encodeAirdropData(merkleRoot: `0x${string}`, lockupDuration: number, vestingDuration: number): `0x${string}`;

export { A0X_ADDRESS, ANON_ADDRESS, type AirdropEntry, CB_BTC_ADDRESS, CLANKER_ADDRESS, Chain, ClankerDeployment, ClankerTokenV4, DEFAULT_SUPPLY, DEGEN_ADDRESS, FEE_CONFIGS, FeeConfigs, HIGHER_ADDRESS, NATIVE_ADDRESS, POOL_POSITIONS, PoolPositions, WETH_ADDRESSES, createMerkleTree, encodeAirdropData, findVanityAddress, findVanityAddressV4, getMerkleProof, getTickFromMarketCap };
