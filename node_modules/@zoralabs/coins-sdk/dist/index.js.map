{"version":3,"sources":["../src/actions/createCoin.ts","../src/constants.ts","../src/utils/validateClientNetwork.ts","../src/metadata/cleanAndValidateMetadataURI.ts","../src/metadata/validateMetadataJSON.ts","../src/metadata/validateMetadataURIContent.ts","../src/utils/attribution.ts","../src/utils/poolConfigUtils.ts","../src/utils/getPrepurchaseHook.ts","../src/utils/getChainFromId.ts","../src/actions/getOnchainCoinDetails.ts","../src/actions/updateCoinURI.ts","../src/actions/updatePayoutRecipient.ts","../src/actions/tradeCoin.ts","../src/client/client.gen.ts","../src/client/sdk.gen.ts","../src/api/api-key.ts","../src/api/queries.ts","../src/api/explore.ts","../src/uploader/metadata.ts","../src/api/internal.ts","../src/uploader/providers/zora.ts"],"sourcesContent":["import { coinFactoryABI as zoraFactoryImplABI } from \"@zoralabs/protocol-deployments\";\nimport {\n  Address,\n  TransactionReceipt,\n  WalletClient,\n  SimulateContractParameters,\n  ContractEventArgsFromTopics,\n  parseEventLogs,\n  zeroAddress,\n  keccak256,\n  toBytes,\n  Hex,\n  Account,\n} from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\nimport { COIN_FACTORY_ADDRESS } from \"../constants\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateMetadataURIContent } from \"../metadata\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { getAttribution } from \"../utils/attribution\";\nimport {\n  COIN_ETH_PAIR_POOL_CONFIG,\n  COIN_ZORA_PAIR_POOL_CONFIG,\n} from \"../utils/poolConfigUtils\";\nimport { getPrepurchaseHook } from \"../utils/getPrepurchaseHook\";\nimport { getChainFromId } from \"../utils/getChainFromId\";\n\nexport type CoinDeploymentLogArgs = ContractEventArgsFromTopics<\n  typeof zoraFactoryImplABI,\n  \"CoinCreatedV4\"\n>;\n\nexport enum DeployCurrency {\n  ZORA = 1,\n  ETH = 2,\n}\n\nexport enum InitialPurchaseCurrency {\n  ETH = 1,\n  // TODO: Add USDC and ZORA support with signature approvals\n}\n\nexport type CreateCoinArgs = {\n  name: string;\n  symbol: string;\n  uri: ValidMetadataURI;\n  chainId?: number;\n  owners?: Address[];\n  payoutRecipient: Address;\n  platformReferrer?: Address;\n  currency?: DeployCurrency;\n  initialPurchase?: {\n    currency: InitialPurchaseCurrency;\n    amount: bigint;\n  };\n};\n\nfunction getPoolConfig(currency: DeployCurrency, chainId: number) {\n  if (currency === DeployCurrency.ZORA && chainId == baseSepolia.id) {\n    throw new Error(\"ZORA is not supported on Base Sepolia\");\n  }\n\n  switch (currency) {\n    case DeployCurrency.ZORA:\n      return COIN_ZORA_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ZORA_PAIR_POOL_CONFIG\n      ];\n    case DeployCurrency.ETH:\n      return COIN_ETH_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ETH_PAIR_POOL_CONFIG\n      ];\n    default:\n      throw new Error(\"Invalid currency\");\n  }\n}\n\nexport async function createCoinCall({\n  name,\n  symbol,\n  uri,\n  owners,\n  payoutRecipient,\n  currency,\n  chainId = base.id,\n  platformReferrer = \"0x0000000000000000000000000000000000000000\",\n  initialPurchase,\n}: CreateCoinArgs): Promise<\n  SimulateContractParameters<typeof zoraFactoryImplABI, \"deploy\">\n> {\n  if (!owners) {\n    owners = [payoutRecipient];\n  }\n\n  if (!currency) {\n    currency = chainId !== base.id ? DeployCurrency.ETH : DeployCurrency.ZORA;\n  }\n\n  const poolConfig = getPoolConfig(currency, chainId);\n\n  // This will throw an error if the metadata is not valid\n  await validateMetadataURIContent(uri);\n\n  let deployHook = {\n    hook: zeroAddress as Address,\n    hookData: \"0x\" as Hex,\n    value: 0n,\n  };\n  if (initialPurchase) {\n    deployHook = await getPrepurchaseHook({\n      initialPurchase,\n      payoutRecipient,\n      chainId,\n    });\n  }\n\n  return {\n    abi: zoraFactoryImplABI,\n    functionName: \"deploy\",\n    address: COIN_FACTORY_ADDRESS,\n    args: [\n      payoutRecipient,\n      owners,\n      uri,\n      name,\n      symbol,\n      poolConfig,\n      platformReferrer,\n      deployHook.hook,\n      deployHook.hookData,\n      keccak256(toBytes(Math.random().toString())), // coinSalt\n    ],\n    value: deployHook.value,\n    dataSuffix: getAttribution(),\n  } as const;\n}\n\n/**\n * Gets the deployed coin address from transaction receipt logs\n * @param receipt Transaction receipt containing the CoinCreated event\n * @returns The deployment information if found\n */\nexport function getCoinCreateFromLogs(\n  receipt: TransactionReceipt,\n): CoinDeploymentLogArgs | undefined {\n  const eventLogs = parseEventLogs({\n    abi: zoraFactoryImplABI,\n    logs: receipt.logs,\n  });\n\n  return eventLogs.find((log) => log.eventName === \"CoinCreatedV4\")?.args;\n}\n\n// Update createCoin to return both receipt and coin address\nexport async function createCoin(\n  call: CreateCoinArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n  options?: {\n    gasMultiplier?: number;\n    account?: Account | Address;\n  },\n) {\n  validateClientNetwork(publicClient);\n\n  const createCoinRequest = await createCoinCall(call);\n  const { request } = await publicClient.simulateContract({\n    ...createCoinRequest,\n    account: options?.account ?? walletClient.account,\n  });\n\n  // Add a 2/5th buffer on gas.\n  if (request.gas) {\n    // Gas limit multiplier is a percentage argument.\n    request.gas = (request.gas * BigInt(options?.gasMultiplier ?? 100)) / 100n;\n  }\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const deployment = getCoinCreateFromLogs(receipt);\n\n  return {\n    hash,\n    receipt,\n    address: deployment?.coin,\n    deployment,\n    chain: getChainFromId(publicClient.chain.id),\n  };\n}\n","import { coinFactoryAddress as zoraFactoryImplAddress } from \"@zoralabs/protocol-deployments\";\nimport { Address } from \"viem\";\nimport { base } from \"viem/chains\";\n\n// this is the same across all chains due to deterministic deploys.\nexport const COIN_FACTORY_ADDRESS = zoraFactoryImplAddress[\"8453\"] as Address;\n\nexport const SUPERCHAIN_WETH_ADDRESS =\n  \"0x4200000000000000000000000000000000000006\";\n\nexport const USDC_WETH_POOLS_BY_CHAIN: Record<number, Address> = {\n  [base.id]: \"0xd0b53D9277642d899DF5C87A3966A349A798F224\",\n};\n","import { PublicClient } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nexport const validateClientNetwork = (\n  publicClient: PublicClient<any, any, any, any>,\n) => {\n  const clientChainId = publicClient?.chain?.id;\n  if (clientChainId === base.id) {\n    return;\n  }\n  if (clientChainId === baseSepolia.id) {\n    return;\n  }\n\n  throw new Error(\n    \"Client network needs to be base or baseSepolia for current coin deployments.\",\n  );\n};\n","import { ValidMetadataURI } from \"../uploader/types\";\n\n/**\n * Clean the metadata URI to HTTPS format\n * @param metadataURI - The metadata URI to clean from IPFS or Arweave\n * @returns The cleaned metadata URI\n * @throws If the metadata URI is a data URI\n */\nexport function cleanAndValidateMetadataURI(uri: ValidMetadataURI) {\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\n      \"ipfs://\",\n      \"https://magic.decentralized-content.com/ipfs/\",\n    );\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return uri.replace(\"ar://\", \"http://arweave.net/\");\n  }\n  if (uri.startsWith(\"data:\")) {\n    return uri;\n    // throw new Error(\"Data URIs are not supported\");\n  }\n  if (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\n    return uri;\n  }\n\n  throw new Error(\"Invalid metadata URI\");\n}\n","export type ValidMetadataJSON = {\n  name: string;\n  description: string;\n  image: string;\n  animation_url?: string;\n  content?: { uri: string; mime?: string };\n};\n\nfunction validateURIString(uri: unknown) {\n  if (typeof uri !== \"string\") {\n    throw new Error(\"URI must be a string\");\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"https://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"data:\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate the metadata JSON object\n * @param metadata - The metadata object to validate\n */\nexport function validateMetadataJSON(metadata: ValidMetadataJSON | unknown) {\n  if (typeof metadata !== \"object\" || !metadata) {\n    throw new Error(\"Metadata must be an object and exist\");\n  }\n  if (typeof (metadata as { name: unknown }).name !== \"string\") {\n    throw new Error(\"Metadata name is required and must be a string\");\n  }\n  if (typeof (metadata as { description: unknown }).description !== \"string\") {\n    throw new Error(\"Metadata description is required and must be a string\");\n  }\n  if (typeof (metadata as { image: unknown }).image === \"string\") {\n    if (!validateURIString((metadata as { image: string }).image)) {\n      throw new Error(\"Metadata image is not a valid URI\");\n    }\n  } else {\n    throw new Error(\"Metadata image is required and must be a string\");\n  }\n  if (\"animation_url\" in metadata) {\n    if (\n      typeof (metadata as { animation_url?: unknown }).animation_url !==\n      \"string\"\n    ) {\n      throw new Error(\"Metadata animation_url, if provided, must be a string\");\n    }\n    if (!validateURIString(metadata.animation_url)) {\n      throw new Error(\"Metadata animation_url is not a valid URI\");\n    }\n  }\n  const content =\n    \"content\" in metadata && (metadata as { content?: unknown }).content;\n  if (content) {\n    if (typeof (content as { uri?: unknown }).uri !== \"string\") {\n      throw new Error(\"If provided, content.uri must be a string\");\n    }\n    if (!validateURIString((content as { uri: string }).uri)) {\n      throw new Error(\"If provided, content.uri must be a valid URI string\");\n    }\n    if (typeof (content as { mime?: unknown }).mime !== \"string\") {\n      throw new Error(\"If provided, content.mime must be a string\");\n    }\n  }\n\n  return true;\n}\n","import { cleanAndValidateMetadataURI } from \"./cleanAndValidateMetadataURI\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { validateMetadataJSON } from \"./validateMetadataJSON\";\n\n/**\n * Validate the metadata URI Content\n * @param metadataURI - The metadata URI to validate\n * @returns true if the metadata is valid, throws an error otherwise\n */\nexport async function validateMetadataURIContent(\n  metadataURI: ValidMetadataURI,\n) {\n  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);\n  const response = await fetch(cleanedURI);\n  if (!response.ok) {\n    throw new Error(\"Metadata fetch failed\");\n  }\n  if (\n    ![\"application/json\", \"text/plain\"].includes(\n      response.headers.get(\"content-type\") ?? \"\",\n    )\n  ) {\n    throw new Error(\"Metadata is not a valid JSON or plain text response type\");\n  }\n  const metadataJson = await response.json();\n  return validateMetadataJSON(metadataJson);\n}\n","import { Hex, keccak256, slice, toHex } from \"viem\";\n\nexport function getAttribution(): Hex {\n  const hash = keccak256(toHex(\"api-sdk.zora.engineering\"));\n  return slice(hash, 0, 4) as Hex;\n}\n","import { encodeMultiCurvePoolConfig } from \"@zoralabs/protocol-deployments\";\nimport { parseUnits, zeroAddress } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nconst ZORA_DECIMALS = 18;\n\n/**\n * =========================\n * COIN_ETH_PAIR_POOL_CONFIG\n * =========================\n */\n\nexport const ZORA_ADDRESS = \"0x1111111111166b7fe7bd91427724b487980afc69\";\n\nconst COIN_ETH_PAIR_LOWER_TICK = -250000;\nconst COIN_ETH_PAIR_UPPER_TICK = -195_000;\nconst COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\"0.05\", 18);\n\nexport const COIN_ETH_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n  [baseSepolia.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n\nconst COIN_ZORA_PAIR_LOWER_TICK = -138_000; // ( -250000 in ETH land ~= $23 = -138_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_UPPER_TICK = -81_000; // (-195_000 ~= 5782 =  -81_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\n  \"0.05\",\n  ZORA_DECIMALS,\n);\n\nexport const COIN_ZORA_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: ZORA_ADDRESS,\n    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n","import {\n  encodeBuySupplyWithMultiHopSwapRouterHookCall,\n  wethAddress,\n} from \"@zoralabs/protocol-deployments\";\nimport { InitialPurchaseCurrency } from \"../actions/createCoin\";\nimport { Address, concat, Hex, pad, toHex } from \"viem\";\nimport { ZORA_ADDRESS } from \"./poolConfigUtils\";\nimport { base } from \"viem/chains\";\n\nconst BASE_UDSC_ADDRESS = \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\";\n\nconst USDC_ZORA_FEE = 3000;\nconst WETH_BASE_FEE = 3000;\n\nconst encodeFee = (fee: number) => pad(toHex(fee), { size: 3 });\n\nexport const getPrepurchaseHook = async ({\n  payoutRecipient,\n  initialPurchase,\n  chainId,\n}: {\n  initialPurchase: {\n    currency: InitialPurchaseCurrency;\n    amount: bigint;\n    amountOutMinimum?: bigint;\n  };\n  payoutRecipient: Address;\n  chainId: number;\n}) => {\n  if (\n    initialPurchase.currency !== InitialPurchaseCurrency.ETH &&\n    chainId !== base.id\n  ) {\n    throw new Error(\"Initial purchase currency and/or chain not supported\");\n  }\n\n  const path = concat([\n    wethAddress[base.id],\n    encodeFee(WETH_BASE_FEE),\n    BASE_UDSC_ADDRESS,\n    encodeFee(USDC_ZORA_FEE),\n    ZORA_ADDRESS,\n  ]);\n\n  return encodeBuySupplyWithMultiHopSwapRouterHookCall({\n    ethValue: initialPurchase.amount,\n    buyRecipient: payoutRecipient,\n    exactInputParams: {\n      path,\n      amountIn: initialPurchase.amount,\n      amountOutMinimum: initialPurchase.amountOutMinimum || 0n,\n    },\n    chainId: base.id,\n  }) as {\n    hook: Address;\n    hookData: Hex;\n    value: bigint;\n  };\n};\n","import { base, baseSepolia, Chain } from \"viem/chains\";\n\nexport function getChainFromId(chainId: number): Chain {\n  if (chainId === base.id) {\n    return base;\n  }\n  if (chainId === baseSepolia.id) {\n    return baseSepolia;\n  }\n\n  throw new Error(`Chain ID ${chainId} not supported`);\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { Address, zeroAddress } from \"viem\";\n\n/**\n * Represents the current state of a coin\n * @typedef {Object} OnchainCoinDetails\n * @property {bigint} balance - The user's balance of the coin\n * @property {PricingResult} marketCap - The market cap of the coin\n * @property {PricingResult} liquidity - The liquidity of the coin\n * @property {Address} pool - Pool address\n * @property {Slot0Result} poolState - Current state of the UniswapV3 pool\n * @property {Address[]} owners - List of owners for the coin\n * @property {Address} payoutRecipient - The payout recipient address\n */\nexport type OnchainCoinDetails = {\n  balance: bigint;\n  owners: readonly Address[];\n  payoutRecipient: Address;\n};\n\n/**\n * Gets the current state of a coin for a user\n * @param {Object} params - The query parameters\n * @param {Address} params.coin - The coin contract address\n * @param {Address} params.user - The user address to check balance for\n * @param {PublicClient} params.publicClient - The viem public client instance\n * @returns {Promise<OnchainCoinDetails>} The coin's current state\n */\nexport async function getOnchainCoinDetails({\n  coin,\n  user = zeroAddress,\n  publicClient,\n}: {\n  coin: Address;\n  user?: Address;\n  publicClient: GenericPublicClient;\n}): Promise<OnchainCoinDetails> {\n  validateClientNetwork(publicClient);\n  const [balance, owners, payoutRecipient] = await publicClient.multicall({\n    contracts: [\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"balanceOf\",\n        args: [user],\n      },\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"owners\",\n      },\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"payoutRecipient\",\n      },\n    ],\n    allowFailure: false,\n  });\n\n  return {\n    balance,\n    owners,\n    payoutRecipient,\n  };\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdateCoinURIArgs = {\n  coin: Address;\n  newURI: string;\n};\n\nexport function updateCoinURICall({\n  newURI,\n  coin,\n}: UpdateCoinURIArgs): SimulateContractParameters {\n  if (!newURI.startsWith(\"ipfs://\")) {\n    throw new Error(\"URI needs to be an ipfs:// prefix uri\");\n  }\n\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setContractURI\",\n    args: [newURI],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updateCoinURI(\n  args: UpdateCoinURIArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updateCoinURICall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const uriUpdated = eventLogs.find(\n    (log) => log.eventName === \"ContractURIUpdated\",\n  );\n\n  return { hash, receipt, uriUpdated };\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdatePayoutRecipientArgs = {\n  coin: Address;\n  newPayoutRecipient: string;\n};\n\nexport function updatePayoutRecipientCall({\n  newPayoutRecipient,\n  coin,\n}: UpdatePayoutRecipientArgs): SimulateContractParameters {\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setPayoutRecipient\",\n    args: [newPayoutRecipient],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updatePayoutRecipient(\n  args: UpdatePayoutRecipientArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updatePayoutRecipientCall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const payoutRecipientUpdated = eventLogs.find(\n    (log) => log.eventName === \"CoinPayoutRecipientUpdated\",\n  );\n\n  return { hash, receipt, payoutRecipientUpdated };\n}\n","import { permit2ABI, permit2Address } from \"@zoralabs/protocol-deployments\";\nimport {\n  Account,\n  Address,\n  erc20Abi,\n  WalletClient,\n  maxUint256,\n  Hex,\n} from \"viem\";\nimport { base } from \"viem/chains\";\nimport { postQuote, PostQuoteResponse } from \"../client\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\n\ntype TradeERC20 = {\n  type: \"erc20\";\n  address: Address;\n};\n\ntype TradeETH = {\n  type: \"eth\";\n};\n\ntype PermitDetails = {\n  token: Address;\n  amount: bigint;\n  expiration: number;\n  nonce: number;\n};\n\ntype Permit = {\n  details: PermitDetails;\n  spender: Address;\n  sigDeadline: bigint;\n};\n\ntype PermitDetailsStringAmounts = {\n  token: Address;\n  amount: string;\n  expiration: number;\n  nonce: number;\n};\n\ntype PermitStringAmounts = {\n  details: PermitDetailsStringAmounts;\n  spender: Address;\n  sigDeadline: string;\n};\n\ntype SignatureWithPermit<TPermit = Permit> = {\n  signature: Hex;\n  permit: TPermit;\n};\n\nfunction convertBigIntToString(permit: Permit): PermitStringAmounts {\n  return {\n    ...permit,\n    details: {\n      ...permit.details,\n      amount: `${permit.details.amount}`,\n    },\n    sigDeadline: `${permit.sigDeadline}`,\n  };\n}\n\nconst PERMIT_SINGLE_TYPES = {\n  PermitSingle: [\n    { name: \"details\", type: \"PermitDetails\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"sigDeadline\", type: \"uint256\" },\n  ],\n  PermitDetails: [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint160\" },\n    { name: \"expiration\", type: \"uint48\" },\n    { name: \"nonce\", type: \"uint48\" },\n  ],\n};\n\ntype TradeCurrency = TradeERC20 | TradeETH;\n\nexport type TradeParameters = {\n  sell: TradeCurrency;\n  buy: TradeCurrency;\n  amountIn: bigint;\n  slippage?: number;\n  // can be smart wallet or EOA here.\n  sender: Address;\n  // needs to be EOA, if signer is blank assumes EOA in sender.\n  signer?: Address;\n  recipient?: Address;\n  signatures?: SignatureWithPermit<PermitStringAmounts>[];\n  permitActiveSeconds?: number;\n};\n\nexport async function tradeCoin({\n  tradeParameters,\n  walletClient,\n  account,\n  publicClient,\n  validateTransaction = true,\n}: {\n  tradeParameters: TradeParameters;\n  walletClient: WalletClient;\n  account?: Account | Address;\n  publicClient: GenericPublicClient;\n  validateTransaction?: boolean;\n}) {\n  const quote = await createTradeCall(tradeParameters);\n\n  if (!account) {\n    account = walletClient.account;\n  }\n  if (!account) {\n    throw new Error(\"Account is required\");\n  }\n\n  // Set default recipient to wallet sender address if not provided\n  if (!tradeParameters.recipient) {\n    tradeParameters.recipient =\n      typeof account === \"string\" ? account : account.address;\n  }\n\n  // todo replace any\n  const signatures: { signature: Hex; permit: any }[] = [];\n  if (quote.permits) {\n    for (const permit of quote.permits) {\n      // return values: amount, expiration, nonce\n      const [, , nonce] = await publicClient.readContract({\n        abi: permit2ABI,\n        address: permit2Address[base.id],\n        functionName: \"allowance\",\n        args: [\n          permit.permit.details.token as Address,\n          typeof account === \"string\" ? account : account.address,\n          permit.permit.spender as Address,\n        ],\n      });\n      const permitToken = permit.permit.details.token as Address;\n      const allowance = await publicClient.readContract({\n        abi: erc20Abi,\n        address: permitToken,\n        functionName: \"allowance\",\n        args: [\n          typeof account === \"string\" ? account : account.address,\n          permit2Address[base.id],\n        ],\n      });\n      if (allowance < BigInt(permit.permit.details.amount)) {\n        const approvalTx = await walletClient.writeContract({\n          abi: erc20Abi,\n          address: permitToken,\n          functionName: \"approve\",\n          chain: base,\n          args: [permit2Address[base.id], maxUint256],\n          account,\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: approvalTx,\n        });\n      }\n      const message = {\n        details: {\n          token: permit.permit.details.token as Address,\n          amount: BigInt(permit.permit.details.amount!),\n          expiration: Number(permit.permit.details.expiration!),\n          nonce: nonce,\n        },\n        spender: permit.permit.spender as Address,\n        sigDeadline: BigInt(permit.permit.sigDeadline!),\n      };\n      const signature = await walletClient.signTypedData({\n        domain: {\n          name: \"Permit2\",\n          chainId: base.id,\n          verifyingContract: permit2Address[base.id],\n        },\n        primaryType: \"PermitSingle\",\n        types: PERMIT_SINGLE_TYPES,\n        message,\n        account: typeof account === \"string\" ? account : account.address,\n      });\n      signatures.push({\n        signature,\n        permit: convertBigIntToString(message),\n      });\n    }\n  }\n\n  const newQuote = await createTradeCall({\n    ...tradeParameters,\n    signatures,\n  });\n\n  const call = {\n    to: newQuote.call.target as Address,\n    data: newQuote.call.data as Hex,\n    value: BigInt(newQuote.call.value),\n    chain: base,\n    account,\n  };\n\n  // simulate call\n  if (validateTransaction) {\n    await publicClient.call(call);\n  }\n\n  const gasEstimate = validateTransaction\n    ? await publicClient.estimateGas(call)\n    : 10_000_000n;\n  const gasPrice = await publicClient.getGasPrice();\n\n  const tx = await walletClient.sendTransaction({\n    ...call,\n    gasPrice,\n    gas: gasEstimate,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash: tx,\n  });\n\n  return receipt;\n}\n\nexport async function createTradeCall(\n  tradeParameters: TradeParameters,\n): Promise<PostQuoteResponse> {\n  if (tradeParameters.slippage && tradeParameters.slippage > 1) {\n    throw new Error(\"Slippage must be less than 1, max 0.99\");\n  }\n  if (tradeParameters.amountIn === BigInt(0)) {\n    throw new Error(\"Amount in must be greater than 0\");\n  }\n\n  const quote = await postQuote({\n    body: {\n      tokenIn: tradeParameters.sell,\n      tokenOut: tradeParameters.buy,\n      amountIn: tradeParameters.amountIn.toString(),\n      slippage: tradeParameters.slippage,\n      chainId: base.id,\n      sender: tradeParameters.sender,\n      recipient: tradeParameters.recipient || tradeParameters.sender,\n      signatures: tradeParameters.signatures,\n    },\n  });\n\n  if (!quote.data) {\n    console.error(quote);\n    throw new Error(\"Quote failed\");\n  }\n\n  return quote.data;\n}\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from \"./types.gen\";\nimport {\n  type Config,\n  type ClientOptions as DefaultClientOptions,\n  createClient,\n  createConfig,\n} from \"@hey-api/client-fetch\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n  (\n    override?: Config<DefaultClientOptions & T>,\n  ) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n  createConfig<ClientOptions>({\n    baseUrl: \"https://api-sdk.zora.engineering/\",\n  }),\n);\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  Options as ClientOptions,\n  TDataShape,\n  Client,\n} from \"@hey-api/client-fetch\";\nimport type {\n  GetApiKeyData,\n  GetApiKeyResponse,\n  GetCoinData,\n  GetCoinResponse,\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n  GetExploreData,\n  GetExploreResponse,\n  GetProfileData,\n  GetProfileResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  PostQuoteData,\n  PostQuoteResponse,\n  PostQuoteError,\n} from \"./types.gen\";\nimport { client as _heyApiClient } from \"./client.gen\";\n\nexport type Options<\n  TData extends TDataShape = TDataShape,\n  ThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n  /**\n   * You can provide a client instance returned by `createClient()` instead of\n   * individual options. This might be also useful if you want to implement a\n   * custom client.\n   */\n  client?: Client;\n  /**\n   * You can pass arbitrary values through the `meta` object. This can be\n   * used to access values that aren't defined as part of the SDK function.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * zoraSDK_apiKey query\n */\nexport const getApiKey = <ThrowOnError extends boolean = false>(\n  options: Options<GetApiKeyData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetApiKeyResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/apiKey\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coin query\n */\nexport const getCoin = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coin\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinComments query\n */\nexport const getCoinComments = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinCommentsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinCommentsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinComments\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinHolders query\n */\nexport const getCoinHolders = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinHoldersData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinHoldersResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinHolders\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinSwaps query\n */\nexport const getCoinSwaps = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinSwapsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinSwapsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinSwaps\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coins query\n */\nexport const getCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coins\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_createUploadJWT mutation\n */\nexport const setCreateUploadJwt = <ThrowOnError extends boolean = false>(\n  options?: Options<SetCreateUploadJwtData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SetCreateUploadJwtResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/createUploadJWT\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * zoraSDK_explore query\n */\nexport const getExplore = <ThrowOnError extends boolean = false>(\n  options: Options<GetExploreData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetExploreResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/explore\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profile query\n */\nexport const getProfile = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profile\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileBalances query\n */\nexport const getProfileBalances = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileBalancesData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileBalancesResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileBalances\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileCoins query\n */\nexport const getProfileCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileCoins\",\n    ...options,\n  });\n};\n\nexport const postQuote = <ThrowOnError extends boolean = false>(\n  options?: Options<PostQuoteData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    PostQuoteResponse,\n    PostQuoteError,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/quote\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n","let apiKey: string | undefined;\nexport function setApiKey(key: string | undefined) {\n  apiKey = key;\n}\n\nexport function getApiKey() {\n  return apiKey;\n}\n\nexport function getApiKeyMeta() {\n  if (!apiKey) {\n    return {};\n  }\n  return {\n    headers: {\n      \"api-key\": apiKey,\n    },\n  };\n}\n","import {\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinData,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  GetProfileData,\n  GetProfileResponse,\n} from \"../client/types.gen\";\nimport {\n  getCoin as getCoinSDK,\n  getCoins as getCoinsSDK,\n  getCoinComments as getCoinCommentsSDK,\n  getCoinHolders as getCoinHoldersSDK,\n  getCoinSwaps as getCoinSwapsSDK,\n  getProfile as getProfileSDK,\n  getProfileBalances as getProfileBalancesSDK,\n  getProfileCoins as getProfileCoinsSDK,\n} from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\nexport type { RequestResult };\n\ntype GetCoinQuery = GetCoinData[\"query\"];\nexport type { GetCoinQuery, GetCoinData };\nexport type { GetCoinResponse } from \"../client/types.gen\";\n\nexport type CoinData = NonNullable<GetCoinResponse[\"zora20Token\"]>;\n\nexport const getCoin = async (\n  query: GetCoinQuery,\n  options?: RequestOptionsType<GetCoinData>,\n): Promise<RequestResult<GetCoinResponse>> => {\n  return await getCoinSDK({\n    ...options,\n    query,\n    ...getApiKeyMeta(),\n  });\n};\n\ntype GetCoinsQuery = GetCoinsData[\"query\"];\nexport type { GetCoinsQuery, GetCoinsData };\nexport type { GetCoinsResponse } from \"../client/types.gen\";\n\nexport const getCoins = async (\n  query: GetCoinsQuery,\n  options?: RequestOptionsType<GetCoinsData>,\n): Promise<RequestResult<GetCoinsResponse>> => {\n  return await getCoinsSDK({\n    query: {\n      coins: query.coins.map((coinData) => JSON.stringify(coinData)) as any,\n    },\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinHoldersQuery = GetCoinHoldersData[\"query\"];\nexport type { GetCoinHoldersQuery, GetCoinHoldersData };\nexport type { GetCoinHoldersResponse } from \"../client/types.gen\";\n\nexport const getCoinHolders = async (\n  query: GetCoinHoldersQuery,\n  options?: RequestOptionsType<GetCoinHoldersData>,\n): Promise<RequestResult<GetCoinHoldersResponse>> => {\n  return await getCoinHoldersSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinSwapsQuery = GetCoinSwapsData[\"query\"];\nexport type { GetCoinSwapsQuery, GetCoinSwapsData };\nexport type { GetCoinSwapsResponse } from \"../client/types.gen\";\n\nexport const getCoinSwaps = async (\n  query: GetCoinSwapsQuery,\n  options?: RequestOptionsType<GetCoinSwapsData>,\n): Promise<RequestResult<GetCoinSwapsResponse>> => {\n  return await getCoinSwapsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinCommentsQuery = GetCoinCommentsData[\"query\"];\nexport type { GetCoinCommentsQuery, GetCoinCommentsData };\nexport type { GetCoinCommentsResponse } from \"../client/types.gen\";\n\nexport const getCoinComments = async (\n  query: GetCoinCommentsQuery,\n  options?: RequestOptionsType<GetCoinCommentsData>,\n): Promise<RequestResult<GetCoinCommentsResponse>> => {\n  return await getCoinCommentsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileQuery = GetProfileData[\"query\"];\nexport type { GetProfileQuery, GetProfileData };\nexport type { GetProfileResponse } from \"../client/types.gen\";\n\nexport const getProfile = async (\n  query: GetProfileQuery,\n  options?: RequestOptionsType<GetProfileData>,\n): Promise<RequestResult<GetProfileResponse>> => {\n  return await getProfileSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileCoinsQuery = GetProfileCoinsData[\"query\"];\nexport type { GetProfileCoinsQuery, GetProfileCoinsData };\nexport type { GetProfileCoinsResponse } from \"../client/types.gen\";\n\nexport const getProfileCoins = async (\n  query: GetProfileCoinsQuery,\n  options?: RequestOptionsType<GetProfileCoinsData>,\n): Promise<RequestResult<GetProfileCoinsResponse>> => {\n  return await getProfileCoinsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileBalancesQuery = GetProfileBalancesData[\"query\"];\nexport type { GetProfileBalancesQuery, GetProfileBalancesData };\nexport type { GetProfileBalancesResponse } from \"../client/types.gen\";\n\nexport const getProfileBalances = async (\n  query: GetProfileBalancesQuery,\n  options?: RequestOptionsType<GetProfileBalancesData>,\n): Promise<RequestResult<GetProfileBalancesResponse>> => {\n  return await getProfileBalancesSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { getExplore as getExploreSDK } from \"../client/sdk.gen\";\nimport type { GetExploreData, GetExploreResponse } from \"../client/types.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\n\n/**\n * The inner type for the explore queries that omits listType.\n * This is used to create the query object for the explore queries.\n */\nexport type QueryRequestType = Omit<GetExploreData[\"query\"], \"listType\">;\n\ntype ExploreResponse = { data?: GetExploreResponse };\n\nexport type ListType = GetExploreData[\"query\"][\"listType\"];\n\nexport type { ExploreResponse };\n\nexport type { GetExploreData };\n\n/**\n * Creates an explore query with the specified list type\n */\nconst createExploreQuery = (\n  query: QueryRequestType,\n  listType: ListType,\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  getExploreSDK({\n    ...options,\n    query: { ...query, listType },\n    ...getApiKeyMeta(),\n  });\n\n/** Get top gaining coins */\nexport const getCoinsTopGainers = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_GAINERS\", options);\n\n/** Get coins with highest 24h volume */\nexport const getCoinsTopVolume24h = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_VOLUME_24H\", options);\n\n/** Get most valuable coins */\nexport const getCoinsMostValuable = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE\", options);\n\n/** Get newly created coins */\nexport const getCoinsNew = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> => createExploreQuery(query, \"NEW\", options);\n\n/** Get recently traded coins */\nexport const getCoinsLastTraded = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED\", options);\n\n/** Get recently traded unique coins */\nexport const getCoinsLastTradedUnique = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED_UNIQUE\", options);\n\nexport const getCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"NEW_CREATORS\", options);\n\nexport const getMostValuableCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE_CREATORS\", options);\n","import {\n  CreateMetadataParameters,\n  Uploader,\n  UploadResult,\n  ValidMetadataURI,\n} from \"./types\";\n\ntype Metadata = {\n  name: string;\n  symbol: string;\n  description: string;\n  image: string;\n  properties?: Record<string, string>;\n  animation_url?: string;\n  content?: {\n    uri: string;\n    mime: string | undefined;\n  };\n};\n\nexport function validateImageMimeType(mimeType: string) {\n  if (\n    ![\n      \"image/png\",\n      \"image/jpeg\",\n      \"image/jpg\",\n      \"image/gif\",\n      \"image/svg+xml\",\n    ].includes(mimeType)\n  ) {\n    throw new Error(\"Image must be a PNG, JPEG, JPG, GIF or SVG\");\n  }\n}\n\nexport function getURLFromUploadResult(uploadResult: UploadResult) {\n  return new URL(uploadResult.url);\n}\n\nexport class CoinMetadataBuilder {\n  private name: string | undefined;\n  private description: string | undefined;\n  private symbol: string | undefined;\n  private imageFile: File | undefined;\n  private imageURL: URL | undefined;\n  private mediaFile: File | undefined;\n  private mediaURL: URL | undefined;\n  private mediaMimeType: string | undefined;\n  private properties: Record<string, string> | undefined;\n\n  withName(name: string) {\n    this.name = name;\n    if (typeof name !== \"string\") {\n      throw new Error(\"Name must be a string\");\n    }\n\n    return this;\n  }\n\n  withSymbol(symbol: string) {\n    this.symbol = symbol;\n    if (typeof symbol !== \"string\") {\n      throw new Error(\"Symbol must be a string\");\n    }\n\n    return this;\n  }\n\n  withDescription(description: string) {\n    this.description = description;\n    if (typeof description !== \"string\") {\n      throw new Error(\"Description must be a string\");\n    }\n\n    return this;\n  }\n\n  withImage(image: File) {\n    if (this.imageURL) {\n      throw new Error(\"Image URL already set\");\n    }\n    if (!(image instanceof File)) {\n      throw new Error(\"Image must be a File\");\n    }\n    validateImageMimeType(image.type);\n    this.imageFile = image;\n\n    return this;\n  }\n\n  withImageURI(imageURI: string) {\n    if (this.imageFile) {\n      throw new Error(\"Image file already set\");\n    }\n    if (typeof imageURI !== \"string\") {\n      throw new Error(\"Image URI must be a string\");\n    }\n    const url = new URL(imageURI);\n    this.imageURL = url;\n\n    return this;\n  }\n\n  withProperties(properties: Record<string, string>) {\n    for (const [key, value] of Object.entries(properties)) {\n      if (typeof key !== \"string\") {\n        throw new Error(\"Property key must be a string\");\n      }\n      if (typeof value !== \"string\") {\n        throw new Error(\"Property value must be a string\");\n      }\n    }\n    if (!this.properties) {\n      this.properties = {};\n    }\n    this.properties = { ...this.properties, ...properties };\n\n    return this;\n  }\n\n  withMedia(media: File) {\n    if (this.mediaURL) {\n      throw new Error(\"Media URL already set\");\n    }\n    if (!(media instanceof File)) {\n      throw new Error(\"Media must be a File\");\n    }\n    this.mediaMimeType = media.type;\n    this.mediaFile = media;\n\n    return this;\n  }\n\n  withMediaURI(mediaURI: string, mediaMimeType: string | undefined) {\n    if (this.mediaFile) {\n      throw new Error(\"Media file already set\");\n    }\n    if (typeof mediaURI !== \"string\") {\n      throw new Error(\"Media URI must be a string\");\n    }\n    const url = new URL(mediaURI);\n    this.mediaURL = url;\n    this.mediaMimeType = mediaMimeType;\n\n    return this;\n  }\n\n  validate() {\n    if (!this.name) {\n      throw new Error(\"Name is required\");\n    }\n    if (!this.symbol) {\n      throw new Error(\"Symbol is required\");\n    }\n    if (!this.imageFile && !this.imageURL) {\n      throw new Error(\"Image is required\");\n    }\n\n    return this;\n  }\n\n  generateMetadata(): Metadata {\n    return {\n      name: this.name!,\n      symbol: this.symbol!,\n      description: this.description!,\n      image: this.imageURL!.toString(),\n      animation_url: this.mediaURL?.toString(),\n      content: this.mediaURL\n        ? {\n            uri: this.mediaURL?.toString(),\n            mime: this.mediaMimeType,\n          }\n        : undefined,\n      properties: this.properties,\n    };\n  }\n\n  async upload(uploader: Uploader): Promise<{\n    url: ValidMetadataURI;\n    createMetadataParameters: CreateMetadataParameters;\n    metadata: Metadata;\n  }> {\n    this.validate();\n\n    if (this.imageFile) {\n      const uploadResult = await uploader.upload(this.imageFile);\n      this.imageURL = getURLFromUploadResult(uploadResult);\n    }\n    if (this.mediaFile) {\n      const uploadResult = await uploader.upload(this.mediaFile);\n      this.mediaURL = getURLFromUploadResult(uploadResult);\n    }\n    const metadata = this.generateMetadata();\n    const uploadResult = await uploader.upload(\n      new File([JSON.stringify(metadata)], \"metadata.json\", {\n        type: \"application/json\",\n      }),\n    );\n\n    return {\n      url: getURLFromUploadResult(uploadResult).toString() as ValidMetadataURI,\n      createMetadataParameters: {\n        name: this.name!,\n        symbol: this.symbol!,\n        uri: uploadResult.url as `ipfs://${string}`,\n      },\n      metadata,\n    };\n  }\n}\n\nexport function createMetadataBuilder() {\n  return new CoinMetadataBuilder();\n}\n","import {\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n} from \"../client/types.gen\";\nimport { setCreateUploadJwt as setCreateUploadJwtSDK } from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\ntype SetCreateUploadJwtQuery = SetCreateUploadJwtData[\"body\"];\nexport type { SetCreateUploadJwtQuery, SetCreateUploadJwtData };\nexport type { SetCreateUploadJwtResponse } from \"../client/types.gen\";\n\nexport const setCreateUploadJwt = async (\n  body: SetCreateUploadJwtQuery,\n  options?: RequestOptionsType<SetCreateUploadJwtData>,\n): Promise<RequestResult<SetCreateUploadJwtResponse>> => {\n  return await setCreateUploadJwtSDK({\n    body,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { Address } from \"viem\";\nimport { Uploader, UploadResult } from \"../types\";\nimport { getApiKey } from \"../../api/api-key\";\nimport { setCreateUploadJwt } from \"../../api/internal\";\n\n/**\n * Zora IPFS uploader implementation\n */\nexport class ZoraUploader implements Uploader {\n  constructor(creatorAddress: Address) {\n    this.creatorAddress = creatorAddress;\n    if (!getApiKey()) {\n      throw new Error(\"API key is required for metadata interactions\");\n    }\n  }\n\n  private creatorAddress: Address;\n  private jwtApiKey: string | undefined;\n  private jwtApiKeyExpiresAt: number | undefined;\n\n  async getJWTApiKey() {\n    if (\n      this.jwtApiKey &&\n      this.jwtApiKeyExpiresAt &&\n      this.jwtApiKeyExpiresAt > Date.now()\n    ) {\n      return this.jwtApiKey;\n    }\n    // Expires in 1 hour\n    this.jwtApiKeyExpiresAt = Date.now() + 1000 * 60 * 60;\n\n    const response = await setCreateUploadJwt({\n      creatorAddress: this.creatorAddress,\n    });\n    this.jwtApiKey = response.data?.createUploadJwtFromApiKey;\n    if (!this.jwtApiKey) {\n      throw new Error(\"Failed to create upload JWT\");\n    }\n\n    return this.jwtApiKey;\n  }\n\n  async upload(file: File): Promise<UploadResult> {\n    const jwtApiKey = await this.getJWTApiKey();\n    const formData = new FormData();\n    formData.append(\"file\", file, file.name);\n\n    const response = await fetch(\n      \"https://ipfs-uploader.zora.co/api/v0/add?cid-version=1\",\n      {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${jwtApiKey}`,\n          Accept: \"*/*\",\n        },\n        body: formData,\n      },\n    );\n\n    if (!response.ok) {\n      console.error(await response.text());\n      throw new Error(`Failed to upload file: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      cid: string;\n      size: number | undefined;\n      mimeType: string | undefined;\n    };\n\n    return {\n      url: `ipfs://${data.cid}`,\n      size: data.size,\n      mimeType: data.mimeType,\n    };\n  }\n}\n\n/**\n * Create a new Zora IPFS uploader\n */\nexport function createZoraUploaderForCreator(\n  creatorAddress: Address,\n): Uploader {\n  return new ZoraUploader(creatorAddress);\n}\n"],"mappings":"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","names":["zeroAddress","keccak256","base","baseSepolia","base","base","baseSepolia","toHex","base","toHex","base","baseSepolia","DeployCurrency","InitialPurchaseCurrency","baseSepolia","base","zeroAddress","keccak256","zeroAddress","coinABI","parseEventLogs","coinABI","parseEventLogs","coinABI","parseEventLogs","coinABI","parseEventLogs","base","base","getCoin","getCoins","getCoinHolders","getCoinSwaps","getCoinComments","getProfile","getProfileCoins","getProfileBalances","uploadResult","setCreateUploadJwt","setCreateUploadJwt"]}