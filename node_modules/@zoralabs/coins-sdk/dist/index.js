// src/actions/createCoin.ts
import { coinFactoryABI as zoraFactoryImplABI } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs,
  zeroAddress as zeroAddress2,
  keccak256 as keccak2562,
  toBytes
} from "viem";
import { base as base6, baseSepolia as baseSepolia4 } from "viem/chains";

// src/constants.ts
import { coinFactoryAddress as zoraFactoryImplAddress } from "@zoralabs/protocol-deployments";
import { base } from "viem/chains";
var COIN_FACTORY_ADDRESS = zoraFactoryImplAddress["8453"];
var USDC_WETH_POOLS_BY_CHAIN = {
  [base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};

// src/utils/validateClientNetwork.ts
import { base as base2, baseSepolia } from "viem/chains";
var validateClientNetwork = (publicClient) => {
  const clientChainId = publicClient?.chain?.id;
  if (clientChainId === base2.id) {
    return;
  }
  if (clientChainId === baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    return uri;
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    response.headers.get("content-type") ?? ""
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/utils/attribution.ts
import { keccak256, slice, toHex } from "viem";
function getAttribution() {
  const hash = keccak256(toHex("api-sdk.zora.engineering"));
  return slice(hash, 0, 4);
}

// src/utils/poolConfigUtils.ts
import { encodeMultiCurvePoolConfig } from "@zoralabs/protocol-deployments";
import { parseUnits, zeroAddress } from "viem";
import { base as base3, baseSepolia as baseSepolia2 } from "viem/chains";
var ZORA_DECIMALS = 18;
var ZORA_ADDRESS = "0x1111111111166b7fe7bd91427724b487980afc69";
var COIN_ETH_PAIR_LOWER_TICK = -25e4;
var COIN_ETH_PAIR_UPPER_TICK = -195e3;
var COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits("0.05", 18);
var COIN_ETH_PAIR_POOL_CONFIG = {
  [base3.id]: encodeMultiCurvePoolConfig({
    currency: zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  }),
  [baseSepolia2.id]: encodeMultiCurvePoolConfig({
    currency: zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};
var COIN_ZORA_PAIR_LOWER_TICK = -138e3;
var COIN_ZORA_PAIR_UPPER_TICK = -81e3;
var COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(
  "0.05",
  ZORA_DECIMALS
);
var COIN_ZORA_PAIR_POOL_CONFIG = {
  [base3.id]: encodeMultiCurvePoolConfig({
    currency: ZORA_ADDRESS,
    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],
    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};

// src/utils/getPrepurchaseHook.ts
import {
  encodeBuySupplyWithMultiHopSwapRouterHookCall,
  wethAddress
} from "@zoralabs/protocol-deployments";
import { concat, pad, toHex as toHex2 } from "viem";
import { base as base4 } from "viem/chains";
var BASE_UDSC_ADDRESS = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
var USDC_ZORA_FEE = 3e3;
var WETH_BASE_FEE = 3e3;
var encodeFee = (fee) => pad(toHex2(fee), { size: 3 });
var getPrepurchaseHook = async ({
  payoutRecipient,
  initialPurchase,
  chainId
}) => {
  if (initialPurchase.currency !== 1 /* ETH */ && chainId !== base4.id) {
    throw new Error("Initial purchase currency and/or chain not supported");
  }
  const path = concat([
    wethAddress[base4.id],
    encodeFee(WETH_BASE_FEE),
    BASE_UDSC_ADDRESS,
    encodeFee(USDC_ZORA_FEE),
    ZORA_ADDRESS
  ]);
  return encodeBuySupplyWithMultiHopSwapRouterHookCall({
    ethValue: initialPurchase.amount,
    buyRecipient: payoutRecipient,
    exactInputParams: {
      path,
      amountIn: initialPurchase.amount,
      amountOutMinimum: initialPurchase.amountOutMinimum || 0n
    },
    chainId: base4.id
  });
};

// src/utils/getChainFromId.ts
import { base as base5, baseSepolia as baseSepolia3 } from "viem/chains";
function getChainFromId(chainId) {
  if (chainId === base5.id) {
    return base5;
  }
  if (chainId === baseSepolia3.id) {
    return baseSepolia3;
  }
  throw new Error(`Chain ID ${chainId} not supported`);
}

// src/actions/createCoin.ts
var DeployCurrency = /* @__PURE__ */ ((DeployCurrency2) => {
  DeployCurrency2[DeployCurrency2["ZORA"] = 1] = "ZORA";
  DeployCurrency2[DeployCurrency2["ETH"] = 2] = "ETH";
  return DeployCurrency2;
})(DeployCurrency || {});
var InitialPurchaseCurrency = /* @__PURE__ */ ((InitialPurchaseCurrency2) => {
  InitialPurchaseCurrency2[InitialPurchaseCurrency2["ETH"] = 1] = "ETH";
  return InitialPurchaseCurrency2;
})(InitialPurchaseCurrency || {});
function getPoolConfig(currency, chainId) {
  if (currency === 1 /* ZORA */ && chainId == baseSepolia4.id) {
    throw new Error("ZORA is not supported on Base Sepolia");
  }
  switch (currency) {
    case 1 /* ZORA */:
      return COIN_ZORA_PAIR_POOL_CONFIG[chainId];
    case 2 /* ETH */:
      return COIN_ETH_PAIR_POOL_CONFIG[chainId];
    default:
      throw new Error("Invalid currency");
  }
}
async function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  currency,
  chainId = base6.id,
  platformReferrer = "0x0000000000000000000000000000000000000000",
  initialPurchase
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  if (!currency) {
    currency = chainId !== base6.id ? 2 /* ETH */ : 1 /* ZORA */;
  }
  const poolConfig = getPoolConfig(currency, chainId);
  await validateMetadataURIContent(uri);
  let deployHook = {
    hook: zeroAddress2,
    hookData: "0x",
    value: 0n
  };
  if (initialPurchase) {
    deployHook = await getPrepurchaseHook({
      initialPurchase,
      payoutRecipient,
      chainId
    });
  }
  return {
    abi: zoraFactoryImplABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      poolConfig,
      platformReferrer,
      deployHook.hook,
      deployHook.hookData,
      keccak2562(toBytes(Math.random().toString()))
      // coinSalt
    ],
    value: deployHook.value,
    dataSuffix: getAttribution()
  };
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = parseEventLogs({
    abi: zoraFactoryImplABI,
    logs: receipt.logs
  });
  return eventLogs.find((log) => log.eventName === "CoinCreatedV4")?.args;
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const createCoinRequest = await createCoinCall(call);
  const { request } = await publicClient.simulateContract({
    ...createCoinRequest,
    account: options?.account ?? walletClient.account
  });
  if (request.gas) {
    request.gas = request.gas * BigInt(options?.gasMultiplier ?? 100) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: deployment?.coin,
    deployment,
    chain: getChainFromId(publicClient.chain.id)
  };
}

// src/actions/getOnchainCoinDetails.ts
import { coinABI } from "@zoralabs/protocol-deployments";
import { zeroAddress as zeroAddress3 } from "viem";
async function getOnchainCoinDetails({
  coin,
  user = zeroAddress3,
  publicClient
}) {
  validateClientNetwork(publicClient);
  const [balance, owners, payoutRecipient] = await publicClient.multicall({
    contracts: [
      {
        address: coin,
        abi: coinABI,
        functionName: "balanceOf",
        args: [user]
      },
      {
        address: coin,
        abi: coinABI,
        functionName: "owners"
      },
      {
        address: coin,
        abi: coinABI,
        functionName: "payoutRecipient"
      }
    ],
    allowFailure: false
  });
  return {
    balance,
    owners,
    payoutRecipient
  };
}

// src/actions/updateCoinURI.ts
import { coinABI as coinABI2 } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs2
} from "viem";
function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: coinABI2,
    address: coin,
    functionName: "setContractURI",
    args: [newURI],
    dataSuffix: getAttribution()
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs2({ abi: coinABI2, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts
import { coinABI as coinABI3 } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs3
} from "viem";
function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: coinABI3,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient],
    dataSuffix: getAttribution()
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs3({ abi: coinABI3, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/actions/tradeCoin.ts
import { permit2ABI, permit2Address } from "@zoralabs/protocol-deployments";
import {
  erc20Abi,
  maxUint256
} from "viem";
import { base as base7 } from "viem/chains";

// src/client/client.gen.ts
import {
  createClient,
  createConfig
} from "@hey-api/client-fetch";
var client = createClient(
  createConfig({
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinComments",
    ...options
  });
};
var getCoinHolders = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinHolders",
    ...options
  });
};
var getCoinSwaps = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinSwaps",
    ...options
  });
};
var getCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coins",
    ...options
  });
};
var setCreateUploadJwt = (options) => {
  return (options?.client ?? client).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/createUploadJWT",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};
var getExplore = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileBalances",
    ...options
  });
};
var getProfileCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileCoins",
    ...options
  });
};
var postQuote = (options) => {
  return (options?.client ?? client).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/quote",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options?.headers
    }
  });
};

// src/actions/tradeCoin.ts
function convertBigIntToString(permit) {
  return {
    ...permit,
    details: {
      ...permit.details,
      amount: `${permit.details.amount}`
    },
    sigDeadline: `${permit.sigDeadline}`
  };
}
var PERMIT_SINGLE_TYPES = {
  PermitSingle: [
    { name: "details", type: "PermitDetails" },
    { name: "spender", type: "address" },
    { name: "sigDeadline", type: "uint256" }
  ],
  PermitDetails: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint160" },
    { name: "expiration", type: "uint48" },
    { name: "nonce", type: "uint48" }
  ]
};
async function tradeCoin({
  tradeParameters,
  walletClient,
  account,
  publicClient,
  validateTransaction = true
}) {
  const quote = await createTradeCall(tradeParameters);
  if (!account) {
    account = walletClient.account;
  }
  if (!account) {
    throw new Error("Account is required");
  }
  if (!tradeParameters.recipient) {
    tradeParameters.recipient = typeof account === "string" ? account : account.address;
  }
  const signatures = [];
  if (quote.permits) {
    for (const permit of quote.permits) {
      const [, , nonce] = await publicClient.readContract({
        abi: permit2ABI,
        address: permit2Address[base7.id],
        functionName: "allowance",
        args: [
          permit.permit.details.token,
          typeof account === "string" ? account : account.address,
          permit.permit.spender
        ]
      });
      const permitToken = permit.permit.details.token;
      const allowance = await publicClient.readContract({
        abi: erc20Abi,
        address: permitToken,
        functionName: "allowance",
        args: [
          typeof account === "string" ? account : account.address,
          permit2Address[base7.id]
        ]
      });
      if (allowance < BigInt(permit.permit.details.amount)) {
        const approvalTx = await walletClient.writeContract({
          abi: erc20Abi,
          address: permitToken,
          functionName: "approve",
          chain: base7,
          args: [permit2Address[base7.id], maxUint256],
          account
        });
        await publicClient.waitForTransactionReceipt({
          hash: approvalTx
        });
      }
      const message = {
        details: {
          token: permit.permit.details.token,
          amount: BigInt(permit.permit.details.amount),
          expiration: Number(permit.permit.details.expiration),
          nonce
        },
        spender: permit.permit.spender,
        sigDeadline: BigInt(permit.permit.sigDeadline)
      };
      const signature = await walletClient.signTypedData({
        domain: {
          name: "Permit2",
          chainId: base7.id,
          verifyingContract: permit2Address[base7.id]
        },
        primaryType: "PermitSingle",
        types: PERMIT_SINGLE_TYPES,
        message,
        account: typeof account === "string" ? account : account.address
      });
      signatures.push({
        signature,
        permit: convertBigIntToString(message)
      });
    }
  }
  const newQuote = await createTradeCall({
    ...tradeParameters,
    signatures
  });
  const call = {
    to: newQuote.call.target,
    data: newQuote.call.data,
    value: BigInt(newQuote.call.value),
    chain: base7,
    account
  };
  if (validateTransaction) {
    await publicClient.call(call);
  }
  const gasEstimate = validateTransaction ? await publicClient.estimateGas(call) : 10000000n;
  const gasPrice = await publicClient.getGasPrice();
  const tx = await walletClient.sendTransaction({
    ...call,
    gasPrice,
    gas: gasEstimate
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: tx
  });
  return receipt;
}
async function createTradeCall(tradeParameters) {
  if (tradeParameters.slippage && tradeParameters.slippage > 1) {
    throw new Error("Slippage must be less than 1, max 0.99");
  }
  if (tradeParameters.amountIn === BigInt(0)) {
    throw new Error("Amount in must be greater than 0");
  }
  const quote = await postQuote({
    body: {
      tokenIn: tradeParameters.sell,
      tokenOut: tradeParameters.buy,
      amountIn: tradeParameters.amountIn.toString(),
      slippage: tradeParameters.slippage,
      chainId: base7.id,
      sender: tradeParameters.sender,
      recipient: tradeParameters.recipient || tradeParameters.sender,
      signatures: tradeParameters.signatures
    }
  });
  if (!quote.data) {
    console.error(quote);
    throw new Error("Quote failed");
  }
  return quote.data;
}

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKey() {
  return apiKey;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    ...getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinHolders2 = async (query, options) => {
  return await getCoinHolders({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinSwaps2 = async (query, options) => {
  return await getCoinSwaps({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileCoins2 = async (query, options) => {
  return await getProfileCoins({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  ...getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
var getCreatorCoins = (query = {}, options) => createExploreQuery(query, "NEW_CREATORS", options);
var getMostValuableCreatorCoins = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE_CREATORS", options);

// src/uploader/metadata.ts
function validateImageMimeType(mimeType) {
  if (![
    "image/png",
    "image/jpeg",
    "image/jpg",
    "image/gif",
    "image/svg+xml"
  ].includes(mimeType)) {
    throw new Error("Image must be a PNG, JPEG, JPG, GIF or SVG");
  }
}
function getURLFromUploadResult(uploadResult) {
  return new URL(uploadResult.url);
}
var CoinMetadataBuilder = class {
  withName(name) {
    this.name = name;
    if (typeof name !== "string") {
      throw new Error("Name must be a string");
    }
    return this;
  }
  withSymbol(symbol) {
    this.symbol = symbol;
    if (typeof symbol !== "string") {
      throw new Error("Symbol must be a string");
    }
    return this;
  }
  withDescription(description) {
    this.description = description;
    if (typeof description !== "string") {
      throw new Error("Description must be a string");
    }
    return this;
  }
  withImage(image) {
    if (this.imageURL) {
      throw new Error("Image URL already set");
    }
    if (!(image instanceof File)) {
      throw new Error("Image must be a File");
    }
    validateImageMimeType(image.type);
    this.imageFile = image;
    return this;
  }
  withImageURI(imageURI) {
    if (this.imageFile) {
      throw new Error("Image file already set");
    }
    if (typeof imageURI !== "string") {
      throw new Error("Image URI must be a string");
    }
    const url = new URL(imageURI);
    this.imageURL = url;
    return this;
  }
  withProperties(properties) {
    for (const [key, value] of Object.entries(properties)) {
      if (typeof key !== "string") {
        throw new Error("Property key must be a string");
      }
      if (typeof value !== "string") {
        throw new Error("Property value must be a string");
      }
    }
    if (!this.properties) {
      this.properties = {};
    }
    this.properties = { ...this.properties, ...properties };
    return this;
  }
  withMedia(media) {
    if (this.mediaURL) {
      throw new Error("Media URL already set");
    }
    if (!(media instanceof File)) {
      throw new Error("Media must be a File");
    }
    this.mediaMimeType = media.type;
    this.mediaFile = media;
    return this;
  }
  withMediaURI(mediaURI, mediaMimeType) {
    if (this.mediaFile) {
      throw new Error("Media file already set");
    }
    if (typeof mediaURI !== "string") {
      throw new Error("Media URI must be a string");
    }
    const url = new URL(mediaURI);
    this.mediaURL = url;
    this.mediaMimeType = mediaMimeType;
    return this;
  }
  validate() {
    if (!this.name) {
      throw new Error("Name is required");
    }
    if (!this.symbol) {
      throw new Error("Symbol is required");
    }
    if (!this.imageFile && !this.imageURL) {
      throw new Error("Image is required");
    }
    return this;
  }
  generateMetadata() {
    return {
      name: this.name,
      symbol: this.symbol,
      description: this.description,
      image: this.imageURL.toString(),
      animation_url: this.mediaURL?.toString(),
      content: this.mediaURL ? {
        uri: this.mediaURL?.toString(),
        mime: this.mediaMimeType
      } : void 0,
      properties: this.properties
    };
  }
  async upload(uploader) {
    this.validate();
    if (this.imageFile) {
      const uploadResult2 = await uploader.upload(this.imageFile);
      this.imageURL = getURLFromUploadResult(uploadResult2);
    }
    if (this.mediaFile) {
      const uploadResult2 = await uploader.upload(this.mediaFile);
      this.mediaURL = getURLFromUploadResult(uploadResult2);
    }
    const metadata = this.generateMetadata();
    const uploadResult = await uploader.upload(
      new File([JSON.stringify(metadata)], "metadata.json", {
        type: "application/json"
      })
    );
    return {
      url: getURLFromUploadResult(uploadResult).toString(),
      createMetadataParameters: {
        name: this.name,
        symbol: this.symbol,
        uri: uploadResult.url
      },
      metadata
    };
  }
};
function createMetadataBuilder() {
  return new CoinMetadataBuilder();
}

// src/api/internal.ts
var setCreateUploadJwt2 = async (body, options) => {
  return await setCreateUploadJwt({
    body,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/uploader/providers/zora.ts
var ZoraUploader = class {
  constructor(creatorAddress) {
    this.creatorAddress = creatorAddress;
    if (!getApiKey()) {
      throw new Error("API key is required for metadata interactions");
    }
  }
  async getJWTApiKey() {
    if (this.jwtApiKey && this.jwtApiKeyExpiresAt && this.jwtApiKeyExpiresAt > Date.now()) {
      return this.jwtApiKey;
    }
    this.jwtApiKeyExpiresAt = Date.now() + 1e3 * 60 * 60;
    const response = await setCreateUploadJwt2({
      creatorAddress: this.creatorAddress
    });
    this.jwtApiKey = response.data?.createUploadJwtFromApiKey;
    if (!this.jwtApiKey) {
      throw new Error("Failed to create upload JWT");
    }
    return this.jwtApiKey;
  }
  async upload(file) {
    const jwtApiKey = await this.getJWTApiKey();
    const formData = new FormData();
    formData.append("file", file, file.name);
    const response = await fetch(
      "https://ipfs-uploader.zora.co/api/v0/add?cid-version=1",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${jwtApiKey}`,
          Accept: "*/*"
        },
        body: formData
      }
    );
    if (!response.ok) {
      console.error(await response.text());
      throw new Error(`Failed to upload file: ${response.statusText}`);
    }
    const data = await response.json();
    return {
      url: `ipfs://${data.cid}`,
      size: data.size,
      mimeType: data.mimeType
    };
  }
};
function createZoraUploaderForCreator(creatorAddress) {
  return new ZoraUploader(creatorAddress);
}
export {
  CoinMetadataBuilder,
  DeployCurrency,
  InitialPurchaseCurrency,
  ZoraUploader,
  cleanAndValidateMetadataURI,
  createCoin,
  createCoinCall,
  createMetadataBuilder,
  createTradeCall,
  createZoraUploaderForCreator,
  getCoin2 as getCoin,
  getCoinComments2 as getCoinComments,
  getCoinCreateFromLogs,
  getCoinHolders2 as getCoinHolders,
  getCoinSwaps2 as getCoinSwaps,
  getCoins2 as getCoins,
  getCoinsLastTraded,
  getCoinsLastTradedUnique,
  getCoinsMostValuable,
  getCoinsNew,
  getCoinsTopGainers,
  getCoinsTopVolume24h,
  getCreatorCoins,
  getMostValuableCreatorCoins,
  getOnchainCoinDetails,
  getProfile2 as getProfile,
  getProfileBalances2 as getProfileBalances,
  getProfileCoins2 as getProfileCoins,
  getURLFromUploadResult,
  setApiKey,
  tradeCoin,
  updateCoinURI,
  updateCoinURICall,
  updatePayoutRecipient,
  updatePayoutRecipientCall,
  validateImageMimeType,
  validateMetadataJSON,
  validateMetadataURIContent
};
//# sourceMappingURL=index.js.map