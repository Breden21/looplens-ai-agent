{"version":3,"sources":["/home/runner/work/zora-protocol-private/zora-protocol-private/packages/coins-sdk/dist/index.cjs","../src/actions/createCoin.ts","../src/constants.ts","../src/utils/validateClientNetwork.ts","../src/metadata/cleanAndValidateMetadataURI.ts","../src/metadata/validateMetadataJSON.ts","../src/metadata/validateMetadataURIContent.ts","../src/utils/attribution.ts","../src/utils/poolConfigUtils.ts","../src/utils/getPrepurchaseHook.ts","../src/utils/getChainFromId.ts","../src/actions/getOnchainCoinDetails.ts","../src/actions/updateCoinURI.ts","../src/actions/updatePayoutRecipient.ts","../src/actions/tradeCoin.ts","../src/client/client.gen.ts","../src/client/sdk.gen.ts","../src/api/api-key.ts","../src/api/queries.ts","../src/api/explore.ts","../src/uploader/metadata.ts","../src/api/internal.ts","../src/uploader/providers/zora.ts"],"names":["base","baseSepolia","toHex","DeployCurrency","InitialPurchaseCurrency","zeroAddress","keccak256","coinABI","parseEventLogs","getCoins","getCoinHolders","getCoinSwaps","getCoinComments","getProfile","getProfileCoins","getProfileBalances","uploadResult","setCreateUploadJwt"],"mappings":"AAAA;ACAA,qEAAqD;AACrD;AAME;AACA;AACA;AACA;AAAA,4BAGK;AACP,qCAAkC;ADLlC;AACA;AEVA;AAEA;AAGO,IAAM,qBAAA,EAAuB,uCAAA,CAAuB,MAAM,CAAA;AAK1D,IAAM,yBAAA,EAAoD;AAAA,EAC/D,CAAC,YAAA,CAAK,EAAE,CAAA,EAAG;AACb,CAAA;AFKA;AACA;AGjBA;AAEO,IAAM,sBAAA,EAAwB,CACnC,YAAA,EAAA,GACG;AACH,EAAA,MAAM,cAAA,kBAAgB,YAAA,2BAAc,KAAA,6BAAO,IAAA;AAC3C,EAAA,GAAA,CAAI,cAAA,IAAkBA,YAAAA,CAAK,EAAA,EAAI;AAC7B,IAAA,MAAA;AAAA,EACF;AACA,EAAA,GAAA,CAAI,cAAA,IAAkB,mBAAA,CAAY,EAAA,EAAI;AACpC,IAAA,MAAA;AAAA,EACF;AAEA,EAAA,MAAM,IAAI,KAAA;AAAA,IACR;AAAA,EACF,CAAA;AACF,CAAA;AHeA;AACA;AIzBO,SAAS,2BAAA,CAA4B,GAAA,EAAuB;AACjE,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AAC7B,IAAA,OAAO,GAAA,CAAI,OAAA;AAAA,MACT,SAAA;AAAA,MACA;AAAA,IACF,CAAA;AAAA,EACF;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AAC3B,IAAA,OAAO,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS,qBAAqB,CAAA;AAAA,EACnD;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AAC3B,IAAA,OAAO,GAAA;AAAA,EAET;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,SAAS,EAAA,GAAK,GAAA,CAAI,UAAA,CAAW,UAAU,CAAA,EAAG;AAC3D,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,sBAAsB,CAAA;AACxC;AJyBA;AACA;AK7CA,SAAS,iBAAA,CAAkB,GAAA,EAAc;AACvC,EAAA,GAAA,CAAI,OAAO,IAAA,IAAQ,QAAA,EAAU;AAC3B,IAAA,MAAM,IAAI,KAAA,CAAM,sBAAsB,CAAA;AAAA,EACxC;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,SAAS,CAAA,EAAG;AAC7B,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AAC3B,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,UAAU,CAAA,EAAG;AAC9B,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,GAAA,CAAI,GAAA,CAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AAC3B,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,OAAO,KAAA;AACT;AAMO,SAAS,oBAAA,CAAqB,QAAA,EAAuC;AAC1E,EAAA,GAAA,CAAI,OAAO,SAAA,IAAa,SAAA,GAAY,CAAC,QAAA,EAAU;AAC7C,IAAA,MAAM,IAAI,KAAA,CAAM,sCAAsC,CAAA;AAAA,EACxD;AACA,EAAA,GAAA,CAAI,OAAQ,QAAA,CAA+B,KAAA,IAAS,QAAA,EAAU;AAC5D,IAAA,MAAM,IAAI,KAAA,CAAM,gDAAgD,CAAA;AAAA,EAClE;AACA,EAAA,GAAA,CAAI,OAAQ,QAAA,CAAsC,YAAA,IAAgB,QAAA,EAAU;AAC1E,IAAA,MAAM,IAAI,KAAA,CAAM,uDAAuD,CAAA;AAAA,EACzE;AACA,EAAA,GAAA,CAAI,OAAQ,QAAA,CAAgC,MAAA,IAAU,QAAA,EAAU;AAC9D,IAAA,GAAA,CAAI,CAAC,iBAAA,CAAmB,QAAA,CAA+B,KAAK,CAAA,EAAG;AAC7D,MAAA,MAAM,IAAI,KAAA,CAAM,mCAAmC,CAAA;AAAA,IACrD;AAAA,EACF,EAAA,KAAO;AACL,IAAA,MAAM,IAAI,KAAA,CAAM,iDAAiD,CAAA;AAAA,EACnE;AACA,EAAA,GAAA,CAAI,gBAAA,GAAmB,QAAA,EAAU;AAC/B,IAAA,GAAA,CACE,OAAQ,QAAA,CAAyC,cAAA,IACjD,QAAA,EACA;AACA,MAAA,MAAM,IAAI,KAAA,CAAM,uDAAuD,CAAA;AAAA,IACzE;AACA,IAAA,GAAA,CAAI,CAAC,iBAAA,CAAkB,QAAA,CAAS,aAAa,CAAA,EAAG;AAC9C,MAAA,MAAM,IAAI,KAAA,CAAM,2CAA2C,CAAA;AAAA,IAC7D;AAAA,EACF;AACA,EAAA,MAAM,QAAA,EACJ,UAAA,GAAa,SAAA,GAAa,QAAA,CAAmC,OAAA;AAC/D,EAAA,GAAA,CAAI,OAAA,EAAS;AACX,IAAA,GAAA,CAAI,OAAQ,OAAA,CAA8B,IAAA,IAAQ,QAAA,EAAU;AAC1D,MAAA,MAAM,IAAI,KAAA,CAAM,2CAA2C,CAAA;AAAA,IAC7D;AACA,IAAA,GAAA,CAAI,CAAC,iBAAA,CAAmB,OAAA,CAA4B,GAAG,CAAA,EAAG;AACxD,MAAA,MAAM,IAAI,KAAA,CAAM,qDAAqD,CAAA;AAAA,IACvE;AACA,IAAA,GAAA,CAAI,OAAQ,OAAA,CAA+B,KAAA,IAAS,QAAA,EAAU;AAC5D,MAAA,MAAM,IAAI,KAAA,CAAM,4CAA4C,CAAA;AAAA,IAC9D;AAAA,EACF;AAEA,EAAA,OAAO,IAAA;AACT;ALoCA;AACA;AMvGA,MAAA,SAAsB,0BAAA,CACpB,WAAA,EACA;AACA,EAAA,MAAM,WAAA,EAAa,2BAAA,CAA4B,WAAW,CAAA;AAC1D,EAAA,MAAM,SAAA,EAAW,MAAM,KAAA,CAAM,UAAU,CAAA;AACvC,EAAA,GAAA,CAAI,CAAC,QAAA,CAAS,EAAA,EAAI;AAChB,IAAA,MAAM,IAAI,KAAA,CAAM,uBAAuB,CAAA;AAAA,EACzC;AACA,EAAA,GAAA,CACE,CAAC,CAAC,kBAAA,EAAoB,YAAY,CAAA,CAAE,QAAA;AAAA,qBAClC,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,cAAc,CAAA,UAAK;AAAA,EAC1C,CAAA,EACA;AACA,IAAA,MAAM,IAAI,KAAA,CAAM,0DAA0D,CAAA;AAAA,EAC5E;AACA,EAAA,MAAM,aAAA,EAAe,MAAM,QAAA,CAAS,IAAA,CAAK,CAAA;AACzC,EAAA,OAAO,oBAAA,CAAqB,YAAY,CAAA;AAC1C;ANqGA;AACA;AOhIA;AAEO,SAAS,cAAA,CAAA,EAAsB;AACpC,EAAA,MAAM,KAAA,EAAO,6BAAA,yBAAU,0BAAgC,CAAC,CAAA;AACxD,EAAA,OAAO,yBAAA,IAAM,EAAM,CAAA,EAAG,CAAC,CAAA;AACzB;APiIA;AACA;AQvIA;AACA;AACA;AAEA,IAAM,cAAA,EAAgB,EAAA;AAQf,IAAM,aAAA,EAAe,4CAAA;AAE5B,IAAM,yBAAA,EAA2B,CAAA,IAAA;AACjC,IAAM,yBAAA,EAA2B,CAAA,KAAA;AACjC,IAAM,sCAAA,EAAwC,EAAA;AAC9C,IAAM,yCAAA,EAA2C,8BAAA,MAAW,EAAQ,EAAE,CAAA;AAE/D,IAAM,0BAAA,EAA4B;AAAA,EACvC,CAACA,YAAAA,CAAK,EAAE,CAAA,EAAG,6DAAA;AAA2B,IACpC,QAAA,EAAU,iBAAA;AAAA,IACV,SAAA,EAAW,CAAC,wBAAwB,CAAA;AAAA,IACpC,SAAA,EAAW,CAAC,wBAAwB,CAAA;AAAA,IACpC,qBAAA,EAAuB,CAAC,qCAAqC,CAAA;AAAA,IAC7D,uBAAA,EAAyB,CAAC,wCAAwC;AAAA,EACpE,CAAC,CAAA;AAAA,EACD,CAACC,mBAAAA,CAAY,EAAE,CAAA,EAAG,6DAAA;AAA2B,IAC3C,QAAA,EAAU,iBAAA;AAAA,IACV,SAAA,EAAW,CAAC,wBAAwB,CAAA;AAAA,IACpC,SAAA,EAAW,CAAC,wBAAwB,CAAA;AAAA,IACpC,qBAAA,EAAuB,CAAC,qCAAqC,CAAA;AAAA,IAC7D,uBAAA,EAAyB,CAAC,wCAAwC;AAAA,EACpE,CAAC;AACH,CAAA;AAEA,IAAM,0BAAA,EAA4B,CAAA,KAAA;AAClC,IAAM,0BAAA,EAA4B,CAAA,IAAA;AAClC,IAAM,uCAAA,EAAyC,EAAA;AAC/C,IAAM,0CAAA,EAA4C,8BAAA;AAAA,EAChD,MAAA;AAAA,EACA;AACF,CAAA;AAEO,IAAM,2BAAA,EAA6B;AAAA,EACxC,CAACD,YAAAA,CAAK,EAAE,CAAA,EAAG,6DAAA;AAA2B,IACpC,QAAA,EAAU,YAAA;AAAA,IACV,SAAA,EAAW,CAAC,yBAAyB,CAAA;AAAA,IACrC,SAAA,EAAW,CAAC,yBAAyB,CAAA;AAAA,IACrC,qBAAA,EAAuB,CAAC,sCAAsC,CAAA;AAAA,IAC9D,uBAAA,EAAyB,CAAC,yCAAyC;AAAA,EACrE,CAAC;AACH,CAAA;AR6HA;AACA;ASlLA;AACE;AACA;AAAA;AAGF;AAEA;AAEA,IAAM,kBAAA,EAAoB,4CAAA;AAE1B,IAAM,cAAA,EAAgB,GAAA;AACtB,IAAM,cAAA,EAAgB,GAAA;AAEtB,IAAM,UAAA,EAAY,CAAC,GAAA,EAAA,GAAgB,uBAAA,yBAAIE,GAAS,CAAA,EAAG,EAAE,IAAA,EAAM,EAAE,CAAC,CAAA;AAEvD,IAAM,mBAAA,EAAqB,MAAA,CAAO;AAAA,EACvC,eAAA;AAAA,EACA,eAAA;AAAA,EACA;AACF,CAAA,EAAA,GAQM;AACJ,EAAA,GAAA,CACE,eAAA,CAAgB,SAAA,IAAA,YAAA,GAChB,QAAA,IAAYF,YAAAA,CAAK,EAAA,EACjB;AACA,IAAA,MAAM,IAAI,KAAA,CAAM,sDAAsD,CAAA;AAAA,EACxE;AAEA,EAAA,MAAM,KAAA,EAAO,0BAAA;AAAO,IAClB,gCAAA,CAAYA,YAAAA,CAAK,EAAE,CAAA;AAAA,IACnB,SAAA,CAAU,aAAa,CAAA;AAAA,IACvB,iBAAA;AAAA,IACA,SAAA,CAAU,aAAa,CAAA;AAAA,IACvB;AAAA,EACF,CAAC,CAAA;AAED,EAAA,OAAO,gFAAA;AAA8C,IACnD,QAAA,EAAU,eAAA,CAAgB,MAAA;AAAA,IAC1B,YAAA,EAAc,eAAA;AAAA,IACd,gBAAA,EAAkB;AAAA,MAChB,IAAA;AAAA,MACA,QAAA,EAAU,eAAA,CAAgB,MAAA;AAAA,MAC1B,gBAAA,EAAkB,eAAA,CAAgB,iBAAA,GAAoB;AAAA,IACxD,CAAA;AAAA,IACA,OAAA,EAASA,YAAAA,CAAK;AAAA,EAChB,CAAC,CAAA;AAKH,CAAA;AT6JA;AACA;AUxNA;AAEO,SAAS,cAAA,CAAe,OAAA,EAAwB;AACrD,EAAA,GAAA,CAAI,QAAA,IAAYA,YAAAA,CAAK,EAAA,EAAI;AACvB,IAAA,OAAOA,YAAAA;AAAA,EACT;AACA,EAAA,GAAA,CAAI,QAAA,IAAYC,mBAAAA,CAAY,EAAA,EAAI;AAC9B,IAAA,OAAOA,mBAAAA;AAAA,EACT;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAAA,SAAA,EAAY,OAAO,CAAA,cAAA,CAAgB,CAAA;AACrD;AVwNA;AACA;ACnMO,IAAK,eAAA,kBAAL,CAAA,CAAKE,eAAAA,EAAAA,GAAL;AACL,EAAAA,eAAAA,CAAAA,eAAAA,CAAA,MAAA,EAAA,EAAO,CAAA,EAAA,EAAP,MAAA;AACA,EAAAA,eAAAA,CAAAA,eAAAA,CAAA,KAAA,EAAA,EAAM,CAAA,EAAA,EAAN,KAAA;AAFU,EAAA,OAAAA,eAAAA;AAAA,CAAA,CAAA,CAAA,eAAA,GAAA,CAAA,CAAA,CAAA;AAKL,IAAK,wBAAA,kBAAL,CAAA,CAAKC,wBAAAA,EAAAA,GAAL;AACL,EAAAA,wBAAAA,CAAAA,wBAAAA,CAAA,KAAA,EAAA,EAAM,CAAA,EAAA,EAAN,KAAA;AADU,EAAA,OAAAA,wBAAAA;AAAA,CAAA,CAAA,CAAA,wBAAA,GAAA,CAAA,CAAA,CAAA;AAoBZ,SAAS,aAAA,CAAc,QAAA,EAA0B,OAAA,EAAiB;AAChE,EAAA,GAAA,CAAI,SAAA,IAAa,aAAA,GAAuB,QAAA,GAAWH,mBAAAA,CAAY,EAAA,EAAI;AACjE,IAAA,MAAM,IAAI,KAAA,CAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,OAAA,CAAQ,QAAA,EAAU;AAAA,IAChB,KAAK,YAAA;AACH,MAAA,OAAO,0BAAA,CACL,OACF,CAAA;AAAA,IACF,KAAK,WAAA;AACH,MAAA,OAAO,yBAAA,CACL,OACF,CAAA;AAAA,IACF,OAAA;AACE,MAAA,MAAM,IAAI,KAAA,CAAM,kBAAkB,CAAA;AAAA,EACtC;AACF;AAEA,MAAA,SAAsB,cAAA,CAAe;AAAA,EACnC,IAAA;AAAA,EACA,MAAA;AAAA,EACA,GAAA;AAAA,EACA,MAAA;AAAA,EACA,eAAA;AAAA,EACA,QAAA;AAAA,EACA,QAAA,EAAUD,YAAAA,CAAK,EAAA;AAAA,EACf,iBAAA,EAAmB,4CAAA;AAAA,EACnB;AACF,CAAA,EAEE;AACA,EAAA,GAAA,CAAI,CAAC,MAAA,EAAQ;AACX,IAAA,OAAA,EAAS,CAAC,eAAe,CAAA;AAAA,EAC3B;AAEA,EAAA,GAAA,CAAI,CAAC,QAAA,EAAU;AACb,IAAA,SAAA,EAAW,QAAA,IAAYA,YAAAA,CAAK,GAAA,EAAK,YAAA,EAAqB,YAAA;AAAA,EACxD;AAEA,EAAA,MAAM,WAAA,EAAa,aAAA,CAAc,QAAA,EAAU,OAAO,CAAA;AAGlD,EAAA,MAAM,0BAAA,CAA2B,GAAG,CAAA;AAEpC,EAAA,IAAI,WAAA,EAAa;AAAA,IACf,IAAA,EAAMK,iBAAAA;AAAA,IACN,QAAA,EAAU,IAAA;AAAA,IACV,KAAA,EAAO;AAAA,EACT,CAAA;AACA,EAAA,GAAA,CAAI,eAAA,EAAiB;AACnB,IAAA,WAAA,EAAa,MAAM,kBAAA,CAAmB;AAAA,MACpC,eAAA;AAAA,MACA,eAAA;AAAA,MACA;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAEA,EAAA,OAAO;AAAA,IACL,GAAA,EAAK,mCAAA;AAAA,IACL,YAAA,EAAc,QAAA;AAAA,IACd,OAAA,EAAS,oBAAA;AAAA,IACT,IAAA,EAAM;AAAA,MACJ,eAAA;AAAA,MACA,MAAA;AAAA,MACA,GAAA;AAAA,MACA,IAAA;AAAA,MACA,MAAA;AAAA,MACA,UAAA;AAAA,MACA,gBAAA;AAAA,MACA,UAAA,CAAW,IAAA;AAAA,MACX,UAAA,CAAW,QAAA;AAAA,MACXC,6BAAAA,2BAAU,IAAQ,CAAK,MAAA,CAAO,CAAA,CAAE,QAAA,CAAS,CAAC,CAAC;AAAA;AAAA,IAC7C,CAAA;AAAA,IACA,KAAA,EAAO,UAAA,CAAW,KAAA;AAAA,IAClB,UAAA,EAAY,cAAA,CAAe;AAAA,EAC7B,CAAA;AACF;AAOO,SAAS,qBAAA,CACd,OAAA,EACmC;AACnC,EAAA,MAAM,UAAA,EAAY,kCAAA;AAAe,IAC/B,GAAA,EAAK,mCAAA;AAAA,IACL,IAAA,EAAM,OAAA,CAAQ;AAAA,EAChB,CAAC,CAAA;AAED,EAAA,uBAAO,SAAA,qBAAU,IAAA,mBAAK,CAAC,GAAA,EAAA,GAAQ,GAAA,CAAI,UAAA,IAAc,eAAe,CAAA,6BAAG,MAAA;AACrE;AAGA,MAAA,SAAsB,UAAA,CACpB,IAAA,EACA,YAAA,EACA,YAAA,EACA,OAAA,EAIA;AACA,EAAA,qBAAA,CAAsB,YAAY,CAAA;AAElC,EAAA,MAAM,kBAAA,EAAoB,MAAM,cAAA,CAAe,IAAI,CAAA;AACnD,EAAA,MAAM,EAAE,QAAQ,EAAA,EAAI,MAAM,YAAA,CAAa,gBAAA,CAAiB;AAAA,IACtD,GAAG,iBAAA;AAAA,IACH,OAAA,mCAAS,OAAA,6BAAS,SAAA,UAAW,YAAA,CAAa;AAAA,EAC5C,CAAC,CAAA;AAGD,EAAA,GAAA,CAAI,OAAA,CAAQ,GAAA,EAAK;AAEf,IAAA,OAAA,CAAQ,IAAA,EAAO,OAAA,CAAQ,IAAA,EAAM,MAAA,kCAAO,OAAA,6BAAS,eAAA,UAAiB,KAAG,EAAA,EAAK,IAAA;AAAA,EACxE;AACA,EAAA,MAAM,KAAA,EAAO,MAAM,YAAA,CAAa,aAAA,CAAc,OAAO,CAAA;AACrD,EAAA,MAAM,QAAA,EAAU,MAAM,YAAA,CAAa,yBAAA,CAA0B,EAAE,KAAK,CAAC,CAAA;AACrE,EAAA,MAAM,WAAA,EAAa,qBAAA,CAAsB,OAAO,CAAA;AAEhD,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA,kBAAS,UAAA,6BAAY,MAAA;AAAA,IACrB,UAAA;AAAA,IACA,KAAA,EAAO,cAAA,CAAe,YAAA,CAAa,KAAA,CAAM,EAAE;AAAA,EAC7C,CAAA;AACF;ADgJA;AACA;AW5UA;AAGA;AA2BA,MAAA,SAAsB,qBAAA,CAAsB;AAAA,EAC1C,IAAA;AAAA,EACA,KAAA,EAAOD,iBAAAA;AAAA,EACP;AACF,CAAA,EAIgC;AAC9B,EAAA,qBAAA,CAAsB,YAAY,CAAA;AAClC,EAAA,MAAM,CAAC,OAAA,EAAS,MAAA,EAAQ,eAAe,EAAA,EAAI,MAAM,YAAA,CAAa,SAAA,CAAU;AAAA,IACtE,SAAA,EAAW;AAAA,MACT;AAAA,QACE,OAAA,EAAS,IAAA;AAAA,QACT,GAAA,EAAK,4BAAA;AAAA,QACL,YAAA,EAAc,WAAA;AAAA,QACd,IAAA,EAAM,CAAC,IAAI;AAAA,MACb,CAAA;AAAA,MACA;AAAA,QACE,OAAA,EAAS,IAAA;AAAA,QACT,GAAA,EAAK,4BAAA;AAAA,QACL,YAAA,EAAc;AAAA,MAChB,CAAA;AAAA,MACA;AAAA,QACE,OAAA,EAAS,IAAA;AAAA,QACT,GAAA,EAAK,4BAAA;AAAA,QACL,YAAA,EAAc;AAAA,MAChB;AAAA,IACF,CAAA;AAAA,IACA,YAAA,EAAc;AAAA,EAChB,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,OAAA;AAAA,IACA,MAAA;AAAA,IACA;AAAA,EACF,CAAA;AACF;AX6SA;AACA;AYjXA;AAEA;AAEE;AAAA;AAYK,SAAS,iBAAA,CAAkB;AAAA,EAChC,MAAA;AAAA,EACA;AACF,CAAA,EAAkD;AAChD,EAAA,GAAA,CAAI,CAAC,MAAA,CAAO,UAAA,CAAW,SAAS,CAAA,EAAG;AACjC,IAAA,MAAM,IAAI,KAAA,CAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,OAAO;AAAA,IACL,GAAA,EAAKE,4BAAAA;AAAA,IACL,OAAA,EAAS,IAAA;AAAA,IACT,YAAA,EAAc,gBAAA;AAAA,IACd,IAAA,EAAM,CAAC,MAAM,CAAA;AAAA,IACb,UAAA,EAAY,cAAA,CAAe;AAAA,EAC7B,CAAA;AACF;AAEA,MAAA,SAAsB,aAAA,CACpB,IAAA,EACA,YAAA,EACA,YAAA,EACA;AACA,EAAA,qBAAA,CAAsB,YAAY,CAAA;AAClC,EAAA,MAAM,KAAA,EAAO,iBAAA,CAAkB,IAAI,CAAA;AACnC,EAAA,MAAM,EAAE,QAAQ,EAAA,EAAI,MAAM,YAAA,CAAa,gBAAA,CAAiB;AAAA,IACtD,GAAG,IAAA;AAAA,IACH,OAAA,EAAS,YAAA,CAAa;AAAA,EACxB,CAAC,CAAA;AACD,EAAA,MAAM,KAAA,EAAO,MAAM,YAAA,CAAa,aAAA,CAAc,OAAO,CAAA;AACrD,EAAA,MAAM,QAAA,EAAU,MAAM,YAAA,CAAa,yBAAA,CAA0B,EAAE,KAAK,CAAC,CAAA;AACrE,EAAA,MAAM,UAAA,EAAYC,kCAAAA,EAAiB,GAAA,EAAKD,4BAAAA,EAAS,IAAA,EAAM,OAAA,CAAQ,KAAK,CAAC,CAAA;AACrE,EAAA,MAAM,WAAA,EAAa,SAAA,CAAU,IAAA;AAAA,IAC3B,CAAC,GAAA,EAAA,GAAQ,GAAA,CAAI,UAAA,IAAc;AAAA,EAC7B,CAAA;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,OAAA,EAAS,WAAW,CAAA;AACrC;AZgWA;AACA;AarZA;AAEA;AAEE;AAAA;AAYK,SAAS,yBAAA,CAA0B;AAAA,EACxC,kBAAA;AAAA,EACA;AACF,CAAA,EAA0D;AACxD,EAAA,OAAO;AAAA,IACL,GAAA,EAAKA,4BAAAA;AAAA,IACL,OAAA,EAAS,IAAA;AAAA,IACT,YAAA,EAAc,oBAAA;AAAA,IACd,IAAA,EAAM,CAAC,kBAAkB,CAAA;AAAA,IACzB,UAAA,EAAY,cAAA,CAAe;AAAA,EAC7B,CAAA;AACF;AAEA,MAAA,SAAsB,qBAAA,CACpB,IAAA,EACA,YAAA,EACA,YAAA,EACA;AACA,EAAA,qBAAA,CAAsB,YAAY,CAAA;AAClC,EAAA,MAAM,KAAA,EAAO,yBAAA,CAA0B,IAAI,CAAA;AAC3C,EAAA,MAAM,EAAE,QAAQ,EAAA,EAAI,MAAM,YAAA,CAAa,gBAAA,CAAiB;AAAA,IACtD,GAAG,IAAA;AAAA,IACH,OAAA,EAAS,YAAA,CAAa;AAAA,EACxB,CAAC,CAAA;AACD,EAAA,MAAM,KAAA,EAAO,MAAM,YAAA,CAAa,aAAA,CAAc,OAAO,CAAA;AACrD,EAAA,MAAM,QAAA,EAAU,MAAM,YAAA,CAAa,yBAAA,CAA0B,EAAE,KAAK,CAAC,CAAA;AACrE,EAAA,MAAM,UAAA,EAAYC,kCAAAA,EAAiB,GAAA,EAAKD,4BAAAA,EAAS,IAAA,EAAM,OAAA,CAAQ,KAAK,CAAC,CAAA;AACrE,EAAA,MAAM,uBAAA,EAAyB,SAAA,CAAU,IAAA;AAAA,IACvC,CAAC,GAAA,EAAA,GAAQ,GAAA,CAAI,UAAA,IAAc;AAAA,EAC7B,CAAA;AAEA,EAAA,OAAO,EAAE,IAAA,EAAM,OAAA,EAAS,uBAAuB,CAAA;AACjD;AbqYA;AACA;ActbA;AACA;AAGE;AAEA;AAAA;AAGF;AdobA;AACA;Ae3bA;AAGE;AACA;AAAA,oDACK;AAeA,IAAM,OAAA,EAAS,uCAAA;AAAA,EACpB,uCAAA;AAA4B,IAC1B,OAAA,EAAS;AAAA,EACX,CAAC;AACH,CAAA;Af6aA;AACA;AgB3XO,IAAM,QAAA,EAAU,CACrB,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,OAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,gBAAA,EAAkB,CAC7B,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,eAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,eAAA,EAAiB,CAC5B,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,cAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,aAAA,EAAe,CAC1B,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,YAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,SAAA,EAAW,CACtB,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,QAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,mBAAA,EAAqB,CAChC,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kCAAQ,OAAA,6BAAS,QAAA,UAAU,QAAA,CAAA,CAAe,IAAA,CAIxC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,kBAAA;AAAA,IACL,GAAG,OAAA;AAAA,IACH,OAAA,EAAS;AAAA,MACP,cAAA,EAAgB,kBAAA;AAAA,MAChB,mBAAG,OAAA,+BAAS;AAAA,IACd;AAAA,EACF,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,WAAA,EAAa,CACxB,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,UAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,WAAA,EAAa,CACxB,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,UAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,mBAAA,EAAqB,CAChC,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,kBAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAKO,IAAM,gBAAA,EAAkB,CAC7B,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kBAAQ,OAAA,CAAQ,MAAA,UAAU,QAAA,CAAA,CAAe,GAAA,CAIvC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,eAAA;AAAA,IACL,GAAG;AAAA,EACL,CAAC,CAAA;AACH,CAAA;AAEO,IAAM,UAAA,EAAY,CACvB,OAAA,EAAA,GACG;AACH,EAAA,OAAA,kCAAQ,OAAA,+BAAS,QAAA,UAAU,QAAA,CAAA,CAAe,IAAA,CAIxC;AAAA,IACA,QAAA,EAAU;AAAA,MACR;AAAA,QACE,IAAA,EAAM,SAAA;AAAA,QACN,IAAA,EAAM;AAAA,MACR;AAAA,IACF,CAAA;AAAA,IACA,GAAA,EAAK,QAAA;AAAA,IACL,GAAG,OAAA;AAAA,IACH,OAAA,EAAS;AAAA,MACP,cAAA,EAAgB,kBAAA;AAAA,MAChB,mBAAG,OAAA,+BAAS;AAAA,IACd;AAAA,EACF,CAAC,CAAA;AACH,CAAA;AhBsRA;AACA;AcliBA,SAAS,qBAAA,CAAsB,MAAA,EAAqC;AAClE,EAAA,OAAO;AAAA,IACL,GAAG,MAAA;AAAA,IACH,OAAA,EAAS;AAAA,MACP,GAAG,MAAA,CAAO,OAAA;AAAA,MACV,MAAA,EAAQ,CAAA,EAAA;AACV,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAEM;AACJ,EAAA;AACU,IAAA;AACA,IAAA;AACA,IAAA;AACV,EAAA;AACA,EAAA;AACU,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACV,EAAA;AACF;AAkBsB;AACpB,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AAOC;AACK,EAAA;AAED,EAAA;AACO,IAAA;AACZ,EAAA;AACK,EAAA;AACO,IAAA;AACZ,EAAA;AAGK,EAAA;AACH,IAAA;AAEF,EAAA;AAGM,EAAA;AACI,EAAA;AACG,IAAA;AAEA,MAAA;AACF,QAAA;AACL,QAAA;AACA,QAAA;AACM,QAAA;AACJ,UAAA;AACA,UAAA;AACA,UAAA;AACF,QAAA;AACD,MAAA;AACK,MAAA;AACA,MAAA;AACC,QAAA;AACL,QAAA;AACA,QAAA;AACM,QAAA;AACJ,UAAA;AACA,UAAA;AACF,QAAA;AACD,MAAA;AACG,MAAA;AACI,QAAA;AACC,UAAA;AACL,UAAA;AACA,UAAA;AACA,UAAA;AACA,UAAA;AACA,UAAA;AACD,QAAA;AACK,QAAA;AACJ,UAAA;AACD,QAAA;AACH,MAAA;AACM,MAAA;AACJ,QAAA;AACE,UAAA;AACA,UAAA;AACA,UAAA;AACA,UAAA;AACF,QAAA;AACA,QAAA;AACA,QAAA;AACF,MAAA;AACM,MAAA;AACJ,QAAA;AACE,UAAA;AACA,UAAA;AACA,UAAA;AACF,QAAA;AACA,QAAA;AACO,QAAA;AACP,QAAA;AACA,QAAA;AACD,MAAA;AACD,MAAA;AACE,QAAA;AACA,QAAA;AACD,MAAA;AACH,IAAA;AACF,EAAA;AAEM,EAAA;AACD,IAAA;AACH,IAAA;AACD,EAAA;AAEY,EAAA;AACP,IAAA;AACE,IAAA;AACC,IAAA;AACAP,IAAAA;AACP,IAAA;AACF,EAAA;AAGI,EAAA;AACI,IAAA;AACR,EAAA;AAEM,EAAA;AAGA,EAAA;AAEK,EAAA;AACN,IAAA;AACH,IAAA;AACK,IAAA;AACN,EAAA;AAEK,EAAA;AACE,IAAA;AACP,EAAA;AAEM,EAAA;AACT;AAEsB;AAGhB,EAAA;AACQ,IAAA;AACZ,EAAA;AACI,EAAA;AACQ,IAAA;AACZ,EAAA;AAEM,EAAA;AACE,IAAA;AACK,MAAA;AACT,MAAA;AACA,MAAA;AACA,MAAA;AACSA,MAAAA;AACD,MAAA;AACR,MAAA;AACA,MAAA;AACF,IAAA;AACD,EAAA;AAEU,EAAA;AACD,IAAA;AACE,IAAA;AACZ,EAAA;AAEa,EAAA;AACf;Adqfe;AACA;AiBnvBX;AACY;AACL,EAAA;AACX;AAEgB;AACP,EAAA;AACT;AAEgB;AACD,EAAA;AACH,IAAA;AACV,EAAA;AACO,EAAA;AACI,IAAA;AACP,MAAA;AACF,IAAA;AACF,EAAA;AACF;AjBmvBe;AACA;AkB9tBQ;AAIR,EAAA;AACR,IAAA;AACH,IAAA;AACG,IAAA;AACJ,EAAA;AACH;AAMaS;AAIE,EAAA;AACJ,IAAA;AACE,MAAA;AACT,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AAMaC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;AlBqqBe;AACA;AmB5yBT;AAMC,EAAA;AACS,EAAA;AACT,EAAA;AACJ;AAGU;AAOA;AAOA;AAOA;AAMA;AAOA;AAMA;AAMA;AnBgwBE;AACA;AoB7zBC;AAEX,EAAA;AACC,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACS,EAAA;AAED,IAAA;AACZ,EAAA;AACF;AAEgB;AACH,EAAA;AACb;AAEa;AAWF,EAAA;AACF,IAAA;AACM,IAAA;AACH,MAAA;AACR,IAAA;AAEO,IAAA;AACT,EAAA;AAEW,EAAA;AACJ,IAAA;AACM,IAAA;AACH,MAAA;AACR,IAAA;AAEO,IAAA;AACT,EAAA;AAEA,EAAA;AACO,IAAA;AACM,IAAA;AACH,MAAA;AACR,IAAA;AAEO,IAAA;AACT,EAAA;AAEU,EAAA;AACC,IAAA;AACD,MAAA;AACR,IAAA;AACM,IAAA;AACE,MAAA;AACR,IAAA;AACA,IAAA;AACK,IAAA;AAEE,IAAA;AACT,EAAA;AAEa,EAAA;AACF,IAAA;AACD,MAAA;AACR,IAAA;AACW,IAAA;AACH,MAAA;AACR,IAAA;AACM,IAAA;AACD,IAAA;AAEE,IAAA;AACT,EAAA;AAEA,EAAA;AACa,IAAA;AACL,MAAA;AACI,QAAA;AACR,MAAA;AACI,MAAA;AACI,QAAA;AACR,MAAA;AACF,IAAA;AACU,IAAA;AACH,MAAA;AACP,IAAA;AACK,IAAA;AAEE,IAAA;AACT,EAAA;AAEU,EAAA;AACC,IAAA;AACD,MAAA;AACR,IAAA;AACM,IAAA;AACE,MAAA;AACR,IAAA;AACK,IAAA;AACA,IAAA;AAEE,IAAA;AACT,EAAA;AAEa,EAAA;AACF,IAAA;AACD,MAAA;AACR,IAAA;AACW,IAAA;AACH,MAAA;AACR,IAAA;AACM,IAAA;AACD,IAAA;AACA,IAAA;AAEE,IAAA;AACT,EAAA;AAEW,EAAA;AACC,IAAA;AACF,MAAA;AACR,IAAA;AACU,IAAA;AACF,MAAA;AACR,IAAA;AACU,IAAA;AACF,MAAA;AACR,IAAA;AAEO,IAAA;AACT,EAAA;AAEA,EAAA;AACS,IAAA;AACC,MAAA;AACE,MAAA;AACR,MAAA;AACO,MAAA;AACP,MAAA;AACS,MAAA;AAEE,QAAA;AACC,QAAA;AAER,MAAA;AACJ,MAAA;AACF,IAAA;AACF,EAAA;AAEa,EAAA;AAKN,IAAA;AAEI,IAAA;AACDC,MAAAA;AACD,MAAA;AACP,IAAA;AACS,IAAA;AACDA,MAAAA;AACD,MAAA;AACP,IAAA;AACM,IAAA;AACA,IAAA;AACK,MAAA;AACD,QAAA;AACP,MAAA;AACH,IAAA;AAEO,IAAA;AACA,MAAA;AACL,MAAA;AACQ,QAAA;AACN,QAAA;AACK,QAAA;AACP,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AACF;AAEgB;AACH,EAAA;AACb;ApBqxBe;AACA;AqB99BFC;AAIE,EAAA;AACX,IAAA;AACG,IAAA;AACA,IAAA;AACJ,EAAA;AACH;ArB69Be;AACA;AsB5+BF;AACC,EAAA;AACL,IAAA;AACA,IAAA;AACG,MAAA;AACR,IAAA;AACF,EAAA;AAMM,EAAA;AAEG,IAAA;AAIE,MAAA;AACT,IAAA;AAEK,IAAA;AAEC,IAAA;AACJ,MAAA;AACD,IAAA;AACI,IAAA;AACK,IAAA;AACF,MAAA;AACR,IAAA;AAEO,IAAA;AACT,EAAA;AAEa,EAAA;AACL,IAAA;AACA,IAAA;AACG,IAAA;AAEH,IAAA;AACJ,MAAA;AACA,MAAA;AACE,QAAA;AACA,QAAA;AACE,UAAA;AACA,UAAA;AACF,QAAA;AACM,QAAA;AACR,MAAA;AACF,IAAA;AAEK,IAAA;AACK,MAAA;AACF,MAAA;AACR,IAAA;AAEM,IAAA;AAMC,IAAA;AACA,MAAA;AACC,MAAA;AACN,MAAA;AACF,IAAA;AACF,EAAA;AACF;AAKgB;AAGH,EAAA;AACb;AtBm9Be;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/zora-protocol-private/zora-protocol-private/packages/coins-sdk/dist/index.cjs","sourcesContent":[null,"import { coinFactoryABI as zoraFactoryImplABI } from \"@zoralabs/protocol-deployments\";\nimport {\n  Address,\n  TransactionReceipt,\n  WalletClient,\n  SimulateContractParameters,\n  ContractEventArgsFromTopics,\n  parseEventLogs,\n  zeroAddress,\n  keccak256,\n  toBytes,\n  Hex,\n  Account,\n} from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\nimport { COIN_FACTORY_ADDRESS } from \"../constants\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateMetadataURIContent } from \"../metadata\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { getAttribution } from \"../utils/attribution\";\nimport {\n  COIN_ETH_PAIR_POOL_CONFIG,\n  COIN_ZORA_PAIR_POOL_CONFIG,\n} from \"../utils/poolConfigUtils\";\nimport { getPrepurchaseHook } from \"../utils/getPrepurchaseHook\";\nimport { getChainFromId } from \"../utils/getChainFromId\";\n\nexport type CoinDeploymentLogArgs = ContractEventArgsFromTopics<\n  typeof zoraFactoryImplABI,\n  \"CoinCreatedV4\"\n>;\n\nexport enum DeployCurrency {\n  ZORA = 1,\n  ETH = 2,\n}\n\nexport enum InitialPurchaseCurrency {\n  ETH = 1,\n  // TODO: Add USDC and ZORA support with signature approvals\n}\n\nexport type CreateCoinArgs = {\n  name: string;\n  symbol: string;\n  uri: ValidMetadataURI;\n  chainId?: number;\n  owners?: Address[];\n  payoutRecipient: Address;\n  platformReferrer?: Address;\n  currency?: DeployCurrency;\n  initialPurchase?: {\n    currency: InitialPurchaseCurrency;\n    amount: bigint;\n  };\n};\n\nfunction getPoolConfig(currency: DeployCurrency, chainId: number) {\n  if (currency === DeployCurrency.ZORA && chainId == baseSepolia.id) {\n    throw new Error(\"ZORA is not supported on Base Sepolia\");\n  }\n\n  switch (currency) {\n    case DeployCurrency.ZORA:\n      return COIN_ZORA_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ZORA_PAIR_POOL_CONFIG\n      ];\n    case DeployCurrency.ETH:\n      return COIN_ETH_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ETH_PAIR_POOL_CONFIG\n      ];\n    default:\n      throw new Error(\"Invalid currency\");\n  }\n}\n\nexport async function createCoinCall({\n  name,\n  symbol,\n  uri,\n  owners,\n  payoutRecipient,\n  currency,\n  chainId = base.id,\n  platformReferrer = \"0x0000000000000000000000000000000000000000\",\n  initialPurchase,\n}: CreateCoinArgs): Promise<\n  SimulateContractParameters<typeof zoraFactoryImplABI, \"deploy\">\n> {\n  if (!owners) {\n    owners = [payoutRecipient];\n  }\n\n  if (!currency) {\n    currency = chainId !== base.id ? DeployCurrency.ETH : DeployCurrency.ZORA;\n  }\n\n  const poolConfig = getPoolConfig(currency, chainId);\n\n  // This will throw an error if the metadata is not valid\n  await validateMetadataURIContent(uri);\n\n  let deployHook = {\n    hook: zeroAddress as Address,\n    hookData: \"0x\" as Hex,\n    value: 0n,\n  };\n  if (initialPurchase) {\n    deployHook = await getPrepurchaseHook({\n      initialPurchase,\n      payoutRecipient,\n      chainId,\n    });\n  }\n\n  return {\n    abi: zoraFactoryImplABI,\n    functionName: \"deploy\",\n    address: COIN_FACTORY_ADDRESS,\n    args: [\n      payoutRecipient,\n      owners,\n      uri,\n      name,\n      symbol,\n      poolConfig,\n      platformReferrer,\n      deployHook.hook,\n      deployHook.hookData,\n      keccak256(toBytes(Math.random().toString())), // coinSalt\n    ],\n    value: deployHook.value,\n    dataSuffix: getAttribution(),\n  } as const;\n}\n\n/**\n * Gets the deployed coin address from transaction receipt logs\n * @param receipt Transaction receipt containing the CoinCreated event\n * @returns The deployment information if found\n */\nexport function getCoinCreateFromLogs(\n  receipt: TransactionReceipt,\n): CoinDeploymentLogArgs | undefined {\n  const eventLogs = parseEventLogs({\n    abi: zoraFactoryImplABI,\n    logs: receipt.logs,\n  });\n\n  return eventLogs.find((log) => log.eventName === \"CoinCreatedV4\")?.args;\n}\n\n// Update createCoin to return both receipt and coin address\nexport async function createCoin(\n  call: CreateCoinArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n  options?: {\n    gasMultiplier?: number;\n    account?: Account | Address;\n  },\n) {\n  validateClientNetwork(publicClient);\n\n  const createCoinRequest = await createCoinCall(call);\n  const { request } = await publicClient.simulateContract({\n    ...createCoinRequest,\n    account: options?.account ?? walletClient.account,\n  });\n\n  // Add a 2/5th buffer on gas.\n  if (request.gas) {\n    // Gas limit multiplier is a percentage argument.\n    request.gas = (request.gas * BigInt(options?.gasMultiplier ?? 100)) / 100n;\n  }\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const deployment = getCoinCreateFromLogs(receipt);\n\n  return {\n    hash,\n    receipt,\n    address: deployment?.coin,\n    deployment,\n    chain: getChainFromId(publicClient.chain.id),\n  };\n}\n","import { coinFactoryAddress as zoraFactoryImplAddress } from \"@zoralabs/protocol-deployments\";\nimport { Address } from \"viem\";\nimport { base } from \"viem/chains\";\n\n// this is the same across all chains due to deterministic deploys.\nexport const COIN_FACTORY_ADDRESS = zoraFactoryImplAddress[\"8453\"] as Address;\n\nexport const SUPERCHAIN_WETH_ADDRESS =\n  \"0x4200000000000000000000000000000000000006\";\n\nexport const USDC_WETH_POOLS_BY_CHAIN: Record<number, Address> = {\n  [base.id]: \"0xd0b53D9277642d899DF5C87A3966A349A798F224\",\n};\n","import { PublicClient } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nexport const validateClientNetwork = (\n  publicClient: PublicClient<any, any, any, any>,\n) => {\n  const clientChainId = publicClient?.chain?.id;\n  if (clientChainId === base.id) {\n    return;\n  }\n  if (clientChainId === baseSepolia.id) {\n    return;\n  }\n\n  throw new Error(\n    \"Client network needs to be base or baseSepolia for current coin deployments.\",\n  );\n};\n","import { ValidMetadataURI } from \"../uploader/types\";\n\n/**\n * Clean the metadata URI to HTTPS format\n * @param metadataURI - The metadata URI to clean from IPFS or Arweave\n * @returns The cleaned metadata URI\n * @throws If the metadata URI is a data URI\n */\nexport function cleanAndValidateMetadataURI(uri: ValidMetadataURI) {\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\n      \"ipfs://\",\n      \"https://magic.decentralized-content.com/ipfs/\",\n    );\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return uri.replace(\"ar://\", \"http://arweave.net/\");\n  }\n  if (uri.startsWith(\"data:\")) {\n    return uri;\n    // throw new Error(\"Data URIs are not supported\");\n  }\n  if (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\n    return uri;\n  }\n\n  throw new Error(\"Invalid metadata URI\");\n}\n","export type ValidMetadataJSON = {\n  name: string;\n  description: string;\n  image: string;\n  animation_url?: string;\n  content?: { uri: string; mime?: string };\n};\n\nfunction validateURIString(uri: unknown) {\n  if (typeof uri !== \"string\") {\n    throw new Error(\"URI must be a string\");\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"https://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"data:\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate the metadata JSON object\n * @param metadata - The metadata object to validate\n */\nexport function validateMetadataJSON(metadata: ValidMetadataJSON | unknown) {\n  if (typeof metadata !== \"object\" || !metadata) {\n    throw new Error(\"Metadata must be an object and exist\");\n  }\n  if (typeof (metadata as { name: unknown }).name !== \"string\") {\n    throw new Error(\"Metadata name is required and must be a string\");\n  }\n  if (typeof (metadata as { description: unknown }).description !== \"string\") {\n    throw new Error(\"Metadata description is required and must be a string\");\n  }\n  if (typeof (metadata as { image: unknown }).image === \"string\") {\n    if (!validateURIString((metadata as { image: string }).image)) {\n      throw new Error(\"Metadata image is not a valid URI\");\n    }\n  } else {\n    throw new Error(\"Metadata image is required and must be a string\");\n  }\n  if (\"animation_url\" in metadata) {\n    if (\n      typeof (metadata as { animation_url?: unknown }).animation_url !==\n      \"string\"\n    ) {\n      throw new Error(\"Metadata animation_url, if provided, must be a string\");\n    }\n    if (!validateURIString(metadata.animation_url)) {\n      throw new Error(\"Metadata animation_url is not a valid URI\");\n    }\n  }\n  const content =\n    \"content\" in metadata && (metadata as { content?: unknown }).content;\n  if (content) {\n    if (typeof (content as { uri?: unknown }).uri !== \"string\") {\n      throw new Error(\"If provided, content.uri must be a string\");\n    }\n    if (!validateURIString((content as { uri: string }).uri)) {\n      throw new Error(\"If provided, content.uri must be a valid URI string\");\n    }\n    if (typeof (content as { mime?: unknown }).mime !== \"string\") {\n      throw new Error(\"If provided, content.mime must be a string\");\n    }\n  }\n\n  return true;\n}\n","import { cleanAndValidateMetadataURI } from \"./cleanAndValidateMetadataURI\";\nimport { ValidMetadataURI } from \"../uploader/types\";\nimport { validateMetadataJSON } from \"./validateMetadataJSON\";\n\n/**\n * Validate the metadata URI Content\n * @param metadataURI - The metadata URI to validate\n * @returns true if the metadata is valid, throws an error otherwise\n */\nexport async function validateMetadataURIContent(\n  metadataURI: ValidMetadataURI,\n) {\n  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);\n  const response = await fetch(cleanedURI);\n  if (!response.ok) {\n    throw new Error(\"Metadata fetch failed\");\n  }\n  if (\n    ![\"application/json\", \"text/plain\"].includes(\n      response.headers.get(\"content-type\") ?? \"\",\n    )\n  ) {\n    throw new Error(\"Metadata is not a valid JSON or plain text response type\");\n  }\n  const metadataJson = await response.json();\n  return validateMetadataJSON(metadataJson);\n}\n","import { Hex, keccak256, slice, toHex } from \"viem\";\n\nexport function getAttribution(): Hex {\n  const hash = keccak256(toHex(\"api-sdk.zora.engineering\"));\n  return slice(hash, 0, 4) as Hex;\n}\n","import { encodeMultiCurvePoolConfig } from \"@zoralabs/protocol-deployments\";\nimport { parseUnits, zeroAddress } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nconst ZORA_DECIMALS = 18;\n\n/**\n * =========================\n * COIN_ETH_PAIR_POOL_CONFIG\n * =========================\n */\n\nexport const ZORA_ADDRESS = \"0x1111111111166b7fe7bd91427724b487980afc69\";\n\nconst COIN_ETH_PAIR_LOWER_TICK = -250000;\nconst COIN_ETH_PAIR_UPPER_TICK = -195_000;\nconst COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\"0.05\", 18);\n\nexport const COIN_ETH_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n  [baseSepolia.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n\nconst COIN_ZORA_PAIR_LOWER_TICK = -138_000; // ( -250000 in ETH land ~= $23 = -138_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_UPPER_TICK = -81_000; // (-195_000 ~= 5782 =  -81_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\n  \"0.05\",\n  ZORA_DECIMALS,\n);\n\nexport const COIN_ZORA_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: ZORA_ADDRESS,\n    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n","import {\n  encodeBuySupplyWithMultiHopSwapRouterHookCall,\n  wethAddress,\n} from \"@zoralabs/protocol-deployments\";\nimport { InitialPurchaseCurrency } from \"../actions/createCoin\";\nimport { Address, concat, Hex, pad, toHex } from \"viem\";\nimport { ZORA_ADDRESS } from \"./poolConfigUtils\";\nimport { base } from \"viem/chains\";\n\nconst BASE_UDSC_ADDRESS = \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\";\n\nconst USDC_ZORA_FEE = 3000;\nconst WETH_BASE_FEE = 3000;\n\nconst encodeFee = (fee: number) => pad(toHex(fee), { size: 3 });\n\nexport const getPrepurchaseHook = async ({\n  payoutRecipient,\n  initialPurchase,\n  chainId,\n}: {\n  initialPurchase: {\n    currency: InitialPurchaseCurrency;\n    amount: bigint;\n    amountOutMinimum?: bigint;\n  };\n  payoutRecipient: Address;\n  chainId: number;\n}) => {\n  if (\n    initialPurchase.currency !== InitialPurchaseCurrency.ETH &&\n    chainId !== base.id\n  ) {\n    throw new Error(\"Initial purchase currency and/or chain not supported\");\n  }\n\n  const path = concat([\n    wethAddress[base.id],\n    encodeFee(WETH_BASE_FEE),\n    BASE_UDSC_ADDRESS,\n    encodeFee(USDC_ZORA_FEE),\n    ZORA_ADDRESS,\n  ]);\n\n  return encodeBuySupplyWithMultiHopSwapRouterHookCall({\n    ethValue: initialPurchase.amount,\n    buyRecipient: payoutRecipient,\n    exactInputParams: {\n      path,\n      amountIn: initialPurchase.amount,\n      amountOutMinimum: initialPurchase.amountOutMinimum || 0n,\n    },\n    chainId: base.id,\n  }) as {\n    hook: Address;\n    hookData: Hex;\n    value: bigint;\n  };\n};\n","import { base, baseSepolia, Chain } from \"viem/chains\";\n\nexport function getChainFromId(chainId: number): Chain {\n  if (chainId === base.id) {\n    return base;\n  }\n  if (chainId === baseSepolia.id) {\n    return baseSepolia;\n  }\n\n  throw new Error(`Chain ID ${chainId} not supported`);\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { Address, zeroAddress } from \"viem\";\n\n/**\n * Represents the current state of a coin\n * @typedef {Object} OnchainCoinDetails\n * @property {bigint} balance - The user's balance of the coin\n * @property {PricingResult} marketCap - The market cap of the coin\n * @property {PricingResult} liquidity - The liquidity of the coin\n * @property {Address} pool - Pool address\n * @property {Slot0Result} poolState - Current state of the UniswapV3 pool\n * @property {Address[]} owners - List of owners for the coin\n * @property {Address} payoutRecipient - The payout recipient address\n */\nexport type OnchainCoinDetails = {\n  balance: bigint;\n  owners: readonly Address[];\n  payoutRecipient: Address;\n};\n\n/**\n * Gets the current state of a coin for a user\n * @param {Object} params - The query parameters\n * @param {Address} params.coin - The coin contract address\n * @param {Address} params.user - The user address to check balance for\n * @param {PublicClient} params.publicClient - The viem public client instance\n * @returns {Promise<OnchainCoinDetails>} The coin's current state\n */\nexport async function getOnchainCoinDetails({\n  coin,\n  user = zeroAddress,\n  publicClient,\n}: {\n  coin: Address;\n  user?: Address;\n  publicClient: GenericPublicClient;\n}): Promise<OnchainCoinDetails> {\n  validateClientNetwork(publicClient);\n  const [balance, owners, payoutRecipient] = await publicClient.multicall({\n    contracts: [\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"balanceOf\",\n        args: [user],\n      },\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"owners\",\n      },\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"payoutRecipient\",\n      },\n    ],\n    allowFailure: false,\n  });\n\n  return {\n    balance,\n    owners,\n    payoutRecipient,\n  };\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdateCoinURIArgs = {\n  coin: Address;\n  newURI: string;\n};\n\nexport function updateCoinURICall({\n  newURI,\n  coin,\n}: UpdateCoinURIArgs): SimulateContractParameters {\n  if (!newURI.startsWith(\"ipfs://\")) {\n    throw new Error(\"URI needs to be an ipfs:// prefix uri\");\n  }\n\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setContractURI\",\n    args: [newURI],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updateCoinURI(\n  args: UpdateCoinURIArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updateCoinURICall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const uriUpdated = eventLogs.find(\n    (log) => log.eventName === \"ContractURIUpdated\",\n  );\n\n  return { hash, receipt, uriUpdated };\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdatePayoutRecipientArgs = {\n  coin: Address;\n  newPayoutRecipient: string;\n};\n\nexport function updatePayoutRecipientCall({\n  newPayoutRecipient,\n  coin,\n}: UpdatePayoutRecipientArgs): SimulateContractParameters {\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setPayoutRecipient\",\n    args: [newPayoutRecipient],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updatePayoutRecipient(\n  args: UpdatePayoutRecipientArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updatePayoutRecipientCall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const payoutRecipientUpdated = eventLogs.find(\n    (log) => log.eventName === \"CoinPayoutRecipientUpdated\",\n  );\n\n  return { hash, receipt, payoutRecipientUpdated };\n}\n","import { permit2ABI, permit2Address } from \"@zoralabs/protocol-deployments\";\nimport {\n  Account,\n  Address,\n  erc20Abi,\n  WalletClient,\n  maxUint256,\n  Hex,\n} from \"viem\";\nimport { base } from \"viem/chains\";\nimport { postQuote, PostQuoteResponse } from \"../client\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\n\ntype TradeERC20 = {\n  type: \"erc20\";\n  address: Address;\n};\n\ntype TradeETH = {\n  type: \"eth\";\n};\n\ntype PermitDetails = {\n  token: Address;\n  amount: bigint;\n  expiration: number;\n  nonce: number;\n};\n\ntype Permit = {\n  details: PermitDetails;\n  spender: Address;\n  sigDeadline: bigint;\n};\n\ntype PermitDetailsStringAmounts = {\n  token: Address;\n  amount: string;\n  expiration: number;\n  nonce: number;\n};\n\ntype PermitStringAmounts = {\n  details: PermitDetailsStringAmounts;\n  spender: Address;\n  sigDeadline: string;\n};\n\ntype SignatureWithPermit<TPermit = Permit> = {\n  signature: Hex;\n  permit: TPermit;\n};\n\nfunction convertBigIntToString(permit: Permit): PermitStringAmounts {\n  return {\n    ...permit,\n    details: {\n      ...permit.details,\n      amount: `${permit.details.amount}`,\n    },\n    sigDeadline: `${permit.sigDeadline}`,\n  };\n}\n\nconst PERMIT_SINGLE_TYPES = {\n  PermitSingle: [\n    { name: \"details\", type: \"PermitDetails\" },\n    { name: \"spender\", type: \"address\" },\n    { name: \"sigDeadline\", type: \"uint256\" },\n  ],\n  PermitDetails: [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint160\" },\n    { name: \"expiration\", type: \"uint48\" },\n    { name: \"nonce\", type: \"uint48\" },\n  ],\n};\n\ntype TradeCurrency = TradeERC20 | TradeETH;\n\nexport type TradeParameters = {\n  sell: TradeCurrency;\n  buy: TradeCurrency;\n  amountIn: bigint;\n  slippage?: number;\n  // can be smart wallet or EOA here.\n  sender: Address;\n  // needs to be EOA, if signer is blank assumes EOA in sender.\n  signer?: Address;\n  recipient?: Address;\n  signatures?: SignatureWithPermit<PermitStringAmounts>[];\n  permitActiveSeconds?: number;\n};\n\nexport async function tradeCoin({\n  tradeParameters,\n  walletClient,\n  account,\n  publicClient,\n  validateTransaction = true,\n}: {\n  tradeParameters: TradeParameters;\n  walletClient: WalletClient;\n  account?: Account | Address;\n  publicClient: GenericPublicClient;\n  validateTransaction?: boolean;\n}) {\n  const quote = await createTradeCall(tradeParameters);\n\n  if (!account) {\n    account = walletClient.account;\n  }\n  if (!account) {\n    throw new Error(\"Account is required\");\n  }\n\n  // Set default recipient to wallet sender address if not provided\n  if (!tradeParameters.recipient) {\n    tradeParameters.recipient =\n      typeof account === \"string\" ? account : account.address;\n  }\n\n  // todo replace any\n  const signatures: { signature: Hex; permit: any }[] = [];\n  if (quote.permits) {\n    for (const permit of quote.permits) {\n      // return values: amount, expiration, nonce\n      const [, , nonce] = await publicClient.readContract({\n        abi: permit2ABI,\n        address: permit2Address[base.id],\n        functionName: \"allowance\",\n        args: [\n          permit.permit.details.token as Address,\n          typeof account === \"string\" ? account : account.address,\n          permit.permit.spender as Address,\n        ],\n      });\n      const permitToken = permit.permit.details.token as Address;\n      const allowance = await publicClient.readContract({\n        abi: erc20Abi,\n        address: permitToken,\n        functionName: \"allowance\",\n        args: [\n          typeof account === \"string\" ? account : account.address,\n          permit2Address[base.id],\n        ],\n      });\n      if (allowance < BigInt(permit.permit.details.amount)) {\n        const approvalTx = await walletClient.writeContract({\n          abi: erc20Abi,\n          address: permitToken,\n          functionName: \"approve\",\n          chain: base,\n          args: [permit2Address[base.id], maxUint256],\n          account,\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: approvalTx,\n        });\n      }\n      const message = {\n        details: {\n          token: permit.permit.details.token as Address,\n          amount: BigInt(permit.permit.details.amount!),\n          expiration: Number(permit.permit.details.expiration!),\n          nonce: nonce,\n        },\n        spender: permit.permit.spender as Address,\n        sigDeadline: BigInt(permit.permit.sigDeadline!),\n      };\n      const signature = await walletClient.signTypedData({\n        domain: {\n          name: \"Permit2\",\n          chainId: base.id,\n          verifyingContract: permit2Address[base.id],\n        },\n        primaryType: \"PermitSingle\",\n        types: PERMIT_SINGLE_TYPES,\n        message,\n        account: typeof account === \"string\" ? account : account.address,\n      });\n      signatures.push({\n        signature,\n        permit: convertBigIntToString(message),\n      });\n    }\n  }\n\n  const newQuote = await createTradeCall({\n    ...tradeParameters,\n    signatures,\n  });\n\n  const call = {\n    to: newQuote.call.target as Address,\n    data: newQuote.call.data as Hex,\n    value: BigInt(newQuote.call.value),\n    chain: base,\n    account,\n  };\n\n  // simulate call\n  if (validateTransaction) {\n    await publicClient.call(call);\n  }\n\n  const gasEstimate = validateTransaction\n    ? await publicClient.estimateGas(call)\n    : 10_000_000n;\n  const gasPrice = await publicClient.getGasPrice();\n\n  const tx = await walletClient.sendTransaction({\n    ...call,\n    gasPrice,\n    gas: gasEstimate,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash: tx,\n  });\n\n  return receipt;\n}\n\nexport async function createTradeCall(\n  tradeParameters: TradeParameters,\n): Promise<PostQuoteResponse> {\n  if (tradeParameters.slippage && tradeParameters.slippage > 1) {\n    throw new Error(\"Slippage must be less than 1, max 0.99\");\n  }\n  if (tradeParameters.amountIn === BigInt(0)) {\n    throw new Error(\"Amount in must be greater than 0\");\n  }\n\n  const quote = await postQuote({\n    body: {\n      tokenIn: tradeParameters.sell,\n      tokenOut: tradeParameters.buy,\n      amountIn: tradeParameters.amountIn.toString(),\n      slippage: tradeParameters.slippage,\n      chainId: base.id,\n      sender: tradeParameters.sender,\n      recipient: tradeParameters.recipient || tradeParameters.sender,\n      signatures: tradeParameters.signatures,\n    },\n  });\n\n  if (!quote.data) {\n    console.error(quote);\n    throw new Error(\"Quote failed\");\n  }\n\n  return quote.data;\n}\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from \"./types.gen\";\nimport {\n  type Config,\n  type ClientOptions as DefaultClientOptions,\n  createClient,\n  createConfig,\n} from \"@hey-api/client-fetch\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n  (\n    override?: Config<DefaultClientOptions & T>,\n  ) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n  createConfig<ClientOptions>({\n    baseUrl: \"https://api-sdk.zora.engineering/\",\n  }),\n);\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  Options as ClientOptions,\n  TDataShape,\n  Client,\n} from \"@hey-api/client-fetch\";\nimport type {\n  GetApiKeyData,\n  GetApiKeyResponse,\n  GetCoinData,\n  GetCoinResponse,\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n  GetExploreData,\n  GetExploreResponse,\n  GetProfileData,\n  GetProfileResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  PostQuoteData,\n  PostQuoteResponse,\n  PostQuoteError,\n} from \"./types.gen\";\nimport { client as _heyApiClient } from \"./client.gen\";\n\nexport type Options<\n  TData extends TDataShape = TDataShape,\n  ThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n  /**\n   * You can provide a client instance returned by `createClient()` instead of\n   * individual options. This might be also useful if you want to implement a\n   * custom client.\n   */\n  client?: Client;\n  /**\n   * You can pass arbitrary values through the `meta` object. This can be\n   * used to access values that aren't defined as part of the SDK function.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * zoraSDK_apiKey query\n */\nexport const getApiKey = <ThrowOnError extends boolean = false>(\n  options: Options<GetApiKeyData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetApiKeyResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/apiKey\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coin query\n */\nexport const getCoin = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coin\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinComments query\n */\nexport const getCoinComments = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinCommentsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinCommentsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinComments\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinHolders query\n */\nexport const getCoinHolders = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinHoldersData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinHoldersResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinHolders\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinSwaps query\n */\nexport const getCoinSwaps = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinSwapsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinSwapsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinSwaps\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coins query\n */\nexport const getCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coins\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_createUploadJWT mutation\n */\nexport const setCreateUploadJwt = <ThrowOnError extends boolean = false>(\n  options?: Options<SetCreateUploadJwtData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SetCreateUploadJwtResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/createUploadJWT\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * zoraSDK_explore query\n */\nexport const getExplore = <ThrowOnError extends boolean = false>(\n  options: Options<GetExploreData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetExploreResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/explore\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profile query\n */\nexport const getProfile = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profile\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileBalances query\n */\nexport const getProfileBalances = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileBalancesData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileBalancesResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileBalances\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileCoins query\n */\nexport const getProfileCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileCoins\",\n    ...options,\n  });\n};\n\nexport const postQuote = <ThrowOnError extends boolean = false>(\n  options?: Options<PostQuoteData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    PostQuoteResponse,\n    PostQuoteError,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/quote\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n","let apiKey: string | undefined;\nexport function setApiKey(key: string | undefined) {\n  apiKey = key;\n}\n\nexport function getApiKey() {\n  return apiKey;\n}\n\nexport function getApiKeyMeta() {\n  if (!apiKey) {\n    return {};\n  }\n  return {\n    headers: {\n      \"api-key\": apiKey,\n    },\n  };\n}\n","import {\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinData,\n  GetCoinHoldersData,\n  GetCoinHoldersResponse,\n  GetCoinResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  GetCoinSwapsData,\n  GetCoinSwapsResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  GetProfileData,\n  GetProfileResponse,\n} from \"../client/types.gen\";\nimport {\n  getCoin as getCoinSDK,\n  getCoins as getCoinsSDK,\n  getCoinComments as getCoinCommentsSDK,\n  getCoinHolders as getCoinHoldersSDK,\n  getCoinSwaps as getCoinSwapsSDK,\n  getProfile as getProfileSDK,\n  getProfileBalances as getProfileBalancesSDK,\n  getProfileCoins as getProfileCoinsSDK,\n} from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\nexport type { RequestResult };\n\ntype GetCoinQuery = GetCoinData[\"query\"];\nexport type { GetCoinQuery, GetCoinData };\nexport type { GetCoinResponse } from \"../client/types.gen\";\n\nexport type CoinData = NonNullable<GetCoinResponse[\"zora20Token\"]>;\n\nexport const getCoin = async (\n  query: GetCoinQuery,\n  options?: RequestOptionsType<GetCoinData>,\n): Promise<RequestResult<GetCoinResponse>> => {\n  return await getCoinSDK({\n    ...options,\n    query,\n    ...getApiKeyMeta(),\n  });\n};\n\ntype GetCoinsQuery = GetCoinsData[\"query\"];\nexport type { GetCoinsQuery, GetCoinsData };\nexport type { GetCoinsResponse } from \"../client/types.gen\";\n\nexport const getCoins = async (\n  query: GetCoinsQuery,\n  options?: RequestOptionsType<GetCoinsData>,\n): Promise<RequestResult<GetCoinsResponse>> => {\n  return await getCoinsSDK({\n    query: {\n      coins: query.coins.map((coinData) => JSON.stringify(coinData)) as any,\n    },\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinHoldersQuery = GetCoinHoldersData[\"query\"];\nexport type { GetCoinHoldersQuery, GetCoinHoldersData };\nexport type { GetCoinHoldersResponse } from \"../client/types.gen\";\n\nexport const getCoinHolders = async (\n  query: GetCoinHoldersQuery,\n  options?: RequestOptionsType<GetCoinHoldersData>,\n): Promise<RequestResult<GetCoinHoldersResponse>> => {\n  return await getCoinHoldersSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinSwapsQuery = GetCoinSwapsData[\"query\"];\nexport type { GetCoinSwapsQuery, GetCoinSwapsData };\nexport type { GetCoinSwapsResponse } from \"../client/types.gen\";\n\nexport const getCoinSwaps = async (\n  query: GetCoinSwapsQuery,\n  options?: RequestOptionsType<GetCoinSwapsData>,\n): Promise<RequestResult<GetCoinSwapsResponse>> => {\n  return await getCoinSwapsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinCommentsQuery = GetCoinCommentsData[\"query\"];\nexport type { GetCoinCommentsQuery, GetCoinCommentsData };\nexport type { GetCoinCommentsResponse } from \"../client/types.gen\";\n\nexport const getCoinComments = async (\n  query: GetCoinCommentsQuery,\n  options?: RequestOptionsType<GetCoinCommentsData>,\n): Promise<RequestResult<GetCoinCommentsResponse>> => {\n  return await getCoinCommentsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileQuery = GetProfileData[\"query\"];\nexport type { GetProfileQuery, GetProfileData };\nexport type { GetProfileResponse } from \"../client/types.gen\";\n\nexport const getProfile = async (\n  query: GetProfileQuery,\n  options?: RequestOptionsType<GetProfileData>,\n): Promise<RequestResult<GetProfileResponse>> => {\n  return await getProfileSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileCoinsQuery = GetProfileCoinsData[\"query\"];\nexport type { GetProfileCoinsQuery, GetProfileCoinsData };\nexport type { GetProfileCoinsResponse } from \"../client/types.gen\";\n\nexport const getProfileCoins = async (\n  query: GetProfileCoinsQuery,\n  options?: RequestOptionsType<GetProfileCoinsData>,\n): Promise<RequestResult<GetProfileCoinsResponse>> => {\n  return await getProfileCoinsSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileBalancesQuery = GetProfileBalancesData[\"query\"];\nexport type { GetProfileBalancesQuery, GetProfileBalancesData };\nexport type { GetProfileBalancesResponse } from \"../client/types.gen\";\n\nexport const getProfileBalances = async (\n  query: GetProfileBalancesQuery,\n  options?: RequestOptionsType<GetProfileBalancesData>,\n): Promise<RequestResult<GetProfileBalancesResponse>> => {\n  return await getProfileBalancesSDK({\n    query,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { getExplore as getExploreSDK } from \"../client/sdk.gen\";\nimport type { GetExploreData, GetExploreResponse } from \"../client/types.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\n\n/**\n * The inner type for the explore queries that omits listType.\n * This is used to create the query object for the explore queries.\n */\nexport type QueryRequestType = Omit<GetExploreData[\"query\"], \"listType\">;\n\ntype ExploreResponse = { data?: GetExploreResponse };\n\nexport type ListType = GetExploreData[\"query\"][\"listType\"];\n\nexport type { ExploreResponse };\n\nexport type { GetExploreData };\n\n/**\n * Creates an explore query with the specified list type\n */\nconst createExploreQuery = (\n  query: QueryRequestType,\n  listType: ListType,\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  getExploreSDK({\n    ...options,\n    query: { ...query, listType },\n    ...getApiKeyMeta(),\n  });\n\n/** Get top gaining coins */\nexport const getCoinsTopGainers = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_GAINERS\", options);\n\n/** Get coins with highest 24h volume */\nexport const getCoinsTopVolume24h = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_VOLUME_24H\", options);\n\n/** Get most valuable coins */\nexport const getCoinsMostValuable = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE\", options);\n\n/** Get newly created coins */\nexport const getCoinsNew = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> => createExploreQuery(query, \"NEW\", options);\n\n/** Get recently traded coins */\nexport const getCoinsLastTraded = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED\", options);\n\n/** Get recently traded unique coins */\nexport const getCoinsLastTradedUnique = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED_UNIQUE\", options);\n\nexport const getCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"NEW_CREATORS\", options);\n\nexport const getMostValuableCreatorCoins = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE_CREATORS\", options);\n","import {\n  CreateMetadataParameters,\n  Uploader,\n  UploadResult,\n  ValidMetadataURI,\n} from \"./types\";\n\ntype Metadata = {\n  name: string;\n  symbol: string;\n  description: string;\n  image: string;\n  properties?: Record<string, string>;\n  animation_url?: string;\n  content?: {\n    uri: string;\n    mime: string | undefined;\n  };\n};\n\nexport function validateImageMimeType(mimeType: string) {\n  if (\n    ![\n      \"image/png\",\n      \"image/jpeg\",\n      \"image/jpg\",\n      \"image/gif\",\n      \"image/svg+xml\",\n    ].includes(mimeType)\n  ) {\n    throw new Error(\"Image must be a PNG, JPEG, JPG, GIF or SVG\");\n  }\n}\n\nexport function getURLFromUploadResult(uploadResult: UploadResult) {\n  return new URL(uploadResult.url);\n}\n\nexport class CoinMetadataBuilder {\n  private name: string | undefined;\n  private description: string | undefined;\n  private symbol: string | undefined;\n  private imageFile: File | undefined;\n  private imageURL: URL | undefined;\n  private mediaFile: File | undefined;\n  private mediaURL: URL | undefined;\n  private mediaMimeType: string | undefined;\n  private properties: Record<string, string> | undefined;\n\n  withName(name: string) {\n    this.name = name;\n    if (typeof name !== \"string\") {\n      throw new Error(\"Name must be a string\");\n    }\n\n    return this;\n  }\n\n  withSymbol(symbol: string) {\n    this.symbol = symbol;\n    if (typeof symbol !== \"string\") {\n      throw new Error(\"Symbol must be a string\");\n    }\n\n    return this;\n  }\n\n  withDescription(description: string) {\n    this.description = description;\n    if (typeof description !== \"string\") {\n      throw new Error(\"Description must be a string\");\n    }\n\n    return this;\n  }\n\n  withImage(image: File) {\n    if (this.imageURL) {\n      throw new Error(\"Image URL already set\");\n    }\n    if (!(image instanceof File)) {\n      throw new Error(\"Image must be a File\");\n    }\n    validateImageMimeType(image.type);\n    this.imageFile = image;\n\n    return this;\n  }\n\n  withImageURI(imageURI: string) {\n    if (this.imageFile) {\n      throw new Error(\"Image file already set\");\n    }\n    if (typeof imageURI !== \"string\") {\n      throw new Error(\"Image URI must be a string\");\n    }\n    const url = new URL(imageURI);\n    this.imageURL = url;\n\n    return this;\n  }\n\n  withProperties(properties: Record<string, string>) {\n    for (const [key, value] of Object.entries(properties)) {\n      if (typeof key !== \"string\") {\n        throw new Error(\"Property key must be a string\");\n      }\n      if (typeof value !== \"string\") {\n        throw new Error(\"Property value must be a string\");\n      }\n    }\n    if (!this.properties) {\n      this.properties = {};\n    }\n    this.properties = { ...this.properties, ...properties };\n\n    return this;\n  }\n\n  withMedia(media: File) {\n    if (this.mediaURL) {\n      throw new Error(\"Media URL already set\");\n    }\n    if (!(media instanceof File)) {\n      throw new Error(\"Media must be a File\");\n    }\n    this.mediaMimeType = media.type;\n    this.mediaFile = media;\n\n    return this;\n  }\n\n  withMediaURI(mediaURI: string, mediaMimeType: string | undefined) {\n    if (this.mediaFile) {\n      throw new Error(\"Media file already set\");\n    }\n    if (typeof mediaURI !== \"string\") {\n      throw new Error(\"Media URI must be a string\");\n    }\n    const url = new URL(mediaURI);\n    this.mediaURL = url;\n    this.mediaMimeType = mediaMimeType;\n\n    return this;\n  }\n\n  validate() {\n    if (!this.name) {\n      throw new Error(\"Name is required\");\n    }\n    if (!this.symbol) {\n      throw new Error(\"Symbol is required\");\n    }\n    if (!this.imageFile && !this.imageURL) {\n      throw new Error(\"Image is required\");\n    }\n\n    return this;\n  }\n\n  generateMetadata(): Metadata {\n    return {\n      name: this.name!,\n      symbol: this.symbol!,\n      description: this.description!,\n      image: this.imageURL!.toString(),\n      animation_url: this.mediaURL?.toString(),\n      content: this.mediaURL\n        ? {\n            uri: this.mediaURL?.toString(),\n            mime: this.mediaMimeType,\n          }\n        : undefined,\n      properties: this.properties,\n    };\n  }\n\n  async upload(uploader: Uploader): Promise<{\n    url: ValidMetadataURI;\n    createMetadataParameters: CreateMetadataParameters;\n    metadata: Metadata;\n  }> {\n    this.validate();\n\n    if (this.imageFile) {\n      const uploadResult = await uploader.upload(this.imageFile);\n      this.imageURL = getURLFromUploadResult(uploadResult);\n    }\n    if (this.mediaFile) {\n      const uploadResult = await uploader.upload(this.mediaFile);\n      this.mediaURL = getURLFromUploadResult(uploadResult);\n    }\n    const metadata = this.generateMetadata();\n    const uploadResult = await uploader.upload(\n      new File([JSON.stringify(metadata)], \"metadata.json\", {\n        type: \"application/json\",\n      }),\n    );\n\n    return {\n      url: getURLFromUploadResult(uploadResult).toString() as ValidMetadataURI,\n      createMetadataParameters: {\n        name: this.name!,\n        symbol: this.symbol!,\n        uri: uploadResult.url as `ipfs://${string}`,\n      },\n      metadata,\n    };\n  }\n}\n\nexport function createMetadataBuilder() {\n  return new CoinMetadataBuilder();\n}\n","import {\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n} from \"../client/types.gen\";\nimport { setCreateUploadJwt as setCreateUploadJwtSDK } from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\ntype SetCreateUploadJwtQuery = SetCreateUploadJwtData[\"body\"];\nexport type { SetCreateUploadJwtQuery, SetCreateUploadJwtData };\nexport type { SetCreateUploadJwtResponse } from \"../client/types.gen\";\n\nexport const setCreateUploadJwt = async (\n  body: SetCreateUploadJwtQuery,\n  options?: RequestOptionsType<SetCreateUploadJwtData>,\n): Promise<RequestResult<SetCreateUploadJwtResponse>> => {\n  return await setCreateUploadJwtSDK({\n    body,\n    ...getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { Address } from \"viem\";\nimport { Uploader, UploadResult } from \"../types\";\nimport { getApiKey } from \"../../api/api-key\";\nimport { setCreateUploadJwt } from \"../../api/internal\";\n\n/**\n * Zora IPFS uploader implementation\n */\nexport class ZoraUploader implements Uploader {\n  constructor(creatorAddress: Address) {\n    this.creatorAddress = creatorAddress;\n    if (!getApiKey()) {\n      throw new Error(\"API key is required for metadata interactions\");\n    }\n  }\n\n  private creatorAddress: Address;\n  private jwtApiKey: string | undefined;\n  private jwtApiKeyExpiresAt: number | undefined;\n\n  async getJWTApiKey() {\n    if (\n      this.jwtApiKey &&\n      this.jwtApiKeyExpiresAt &&\n      this.jwtApiKeyExpiresAt > Date.now()\n    ) {\n      return this.jwtApiKey;\n    }\n    // Expires in 1 hour\n    this.jwtApiKeyExpiresAt = Date.now() + 1000 * 60 * 60;\n\n    const response = await setCreateUploadJwt({\n      creatorAddress: this.creatorAddress,\n    });\n    this.jwtApiKey = response.data?.createUploadJwtFromApiKey;\n    if (!this.jwtApiKey) {\n      throw new Error(\"Failed to create upload JWT\");\n    }\n\n    return this.jwtApiKey;\n  }\n\n  async upload(file: File): Promise<UploadResult> {\n    const jwtApiKey = await this.getJWTApiKey();\n    const formData = new FormData();\n    formData.append(\"file\", file, file.name);\n\n    const response = await fetch(\n      \"https://ipfs-uploader.zora.co/api/v0/add?cid-version=1\",\n      {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${jwtApiKey}`,\n          Accept: \"*/*\",\n        },\n        body: formData,\n      },\n    );\n\n    if (!response.ok) {\n      console.error(await response.text());\n      throw new Error(`Failed to upload file: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      cid: string;\n      size: number | undefined;\n      mimeType: string | undefined;\n    };\n\n    return {\n      url: `ipfs://${data.cid}`,\n      size: data.size,\n      mimeType: data.mimeType,\n    };\n  }\n}\n\n/**\n * Create a new Zora IPFS uploader\n */\nexport function createZoraUploaderForCreator(\n  creatorAddress: Address,\n): Uploader {\n  return new ZoraUploader(creatorAddress);\n}\n"]}