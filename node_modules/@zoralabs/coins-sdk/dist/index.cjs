"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/actions/createCoin.ts
var _protocoldeployments = require('@zoralabs/protocol-deployments');





var _viem = require('viem');
var _chains = require('viem/chains');

// src/constants.ts


var COIN_FACTORY_ADDRESS = _protocoldeployments.coinFactoryAddress["8453"];
var USDC_WETH_POOLS_BY_CHAIN = {
  [_chains.base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};

// src/utils/validateClientNetwork.ts

var validateClientNetwork = (publicClient) => {
  const clientChainId = _optionalChain([publicClient, 'optionalAccess', _ => _.chain, 'optionalAccess', _2 => _2.id]);
  if (clientChainId === _chains.base.id) {
    return;
  }
  if (clientChainId === _chains.baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    return uri;
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    _nullishCoalesce(response.headers.get("content-type"), () => ( ""))
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/utils/attribution.ts

function getAttribution() {
  const hash = _viem.keccak256.call(void 0, _viem.toHex.call(void 0, "api-sdk.zora.engineering"));
  return _viem.slice.call(void 0, hash, 0, 4);
}

// src/utils/poolConfigUtils.ts



var ZORA_DECIMALS = 18;
var ZORA_ADDRESS = "0x1111111111166b7fe7bd91427724b487980afc69";
var COIN_ETH_PAIR_LOWER_TICK = -25e4;
var COIN_ETH_PAIR_UPPER_TICK = -195e3;
var COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = _viem.parseUnits.call(void 0, "0.05", 18);
var COIN_ETH_PAIR_POOL_CONFIG = {
  [_chains.base.id]: _protocoldeployments.encodeMultiCurvePoolConfig.call(void 0, {
    currency: _viem.zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  }),
  [_chains.baseSepolia.id]: _protocoldeployments.encodeMultiCurvePoolConfig.call(void 0, {
    currency: _viem.zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};
var COIN_ZORA_PAIR_LOWER_TICK = -138e3;
var COIN_ZORA_PAIR_UPPER_TICK = -81e3;
var COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = _viem.parseUnits.call(void 0, 
  "0.05",
  ZORA_DECIMALS
);
var COIN_ZORA_PAIR_POOL_CONFIG = {
  [_chains.base.id]: _protocoldeployments.encodeMultiCurvePoolConfig.call(void 0, {
    currency: ZORA_ADDRESS,
    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],
    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};

// src/utils/getPrepurchaseHook.ts






var BASE_UDSC_ADDRESS = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";
var USDC_ZORA_FEE = 3e3;
var WETH_BASE_FEE = 3e3;
var encodeFee = (fee) => _viem.pad.call(void 0, _viem.toHex.call(void 0, fee), { size: 3 });
var getPrepurchaseHook = async ({
  payoutRecipient,
  initialPurchase,
  chainId
}) => {
  if (initialPurchase.currency !== 1 /* ETH */ && chainId !== _chains.base.id) {
    throw new Error("Initial purchase currency and/or chain not supported");
  }
  const path = _viem.concat.call(void 0, [
    _protocoldeployments.wethAddress[_chains.base.id],
    encodeFee(WETH_BASE_FEE),
    BASE_UDSC_ADDRESS,
    encodeFee(USDC_ZORA_FEE),
    ZORA_ADDRESS
  ]);
  return _protocoldeployments.encodeBuySupplyWithMultiHopSwapRouterHookCall.call(void 0, {
    ethValue: initialPurchase.amount,
    buyRecipient: payoutRecipient,
    exactInputParams: {
      path,
      amountIn: initialPurchase.amount,
      amountOutMinimum: initialPurchase.amountOutMinimum || 0n
    },
    chainId: _chains.base.id
  });
};

// src/utils/getChainFromId.ts

function getChainFromId(chainId) {
  if (chainId === _chains.base.id) {
    return _chains.base;
  }
  if (chainId === _chains.baseSepolia.id) {
    return _chains.baseSepolia;
  }
  throw new Error(`Chain ID ${chainId} not supported`);
}

// src/actions/createCoin.ts
var DeployCurrency = /* @__PURE__ */ ((DeployCurrency2) => {
  DeployCurrency2[DeployCurrency2["ZORA"] = 1] = "ZORA";
  DeployCurrency2[DeployCurrency2["ETH"] = 2] = "ETH";
  return DeployCurrency2;
})(DeployCurrency || {});
var InitialPurchaseCurrency = /* @__PURE__ */ ((InitialPurchaseCurrency2) => {
  InitialPurchaseCurrency2[InitialPurchaseCurrency2["ETH"] = 1] = "ETH";
  return InitialPurchaseCurrency2;
})(InitialPurchaseCurrency || {});
function getPoolConfig(currency, chainId) {
  if (currency === 1 /* ZORA */ && chainId == _chains.baseSepolia.id) {
    throw new Error("ZORA is not supported on Base Sepolia");
  }
  switch (currency) {
    case 1 /* ZORA */:
      return COIN_ZORA_PAIR_POOL_CONFIG[chainId];
    case 2 /* ETH */:
      return COIN_ETH_PAIR_POOL_CONFIG[chainId];
    default:
      throw new Error("Invalid currency");
  }
}
async function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  currency,
  chainId = _chains.base.id,
  platformReferrer = "0x0000000000000000000000000000000000000000",
  initialPurchase
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  if (!currency) {
    currency = chainId !== _chains.base.id ? 2 /* ETH */ : 1 /* ZORA */;
  }
  const poolConfig = getPoolConfig(currency, chainId);
  await validateMetadataURIContent(uri);
  let deployHook = {
    hook: _viem.zeroAddress,
    hookData: "0x",
    value: 0n
  };
  if (initialPurchase) {
    deployHook = await getPrepurchaseHook({
      initialPurchase,
      payoutRecipient,
      chainId
    });
  }
  return {
    abi: _protocoldeployments.coinFactoryABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      poolConfig,
      platformReferrer,
      deployHook.hook,
      deployHook.hookData,
      _viem.keccak256.call(void 0, _viem.toBytes.call(void 0, Math.random().toString()))
      // coinSalt
    ],
    value: deployHook.value,
    dataSuffix: getAttribution()
  };
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = _viem.parseEventLogs.call(void 0, {
    abi: _protocoldeployments.coinFactoryABI,
    logs: receipt.logs
  });
  return _optionalChain([eventLogs, 'access', _3 => _3.find, 'call', _4 => _4((log) => log.eventName === "CoinCreatedV4"), 'optionalAccess', _5 => _5.args]);
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const createCoinRequest = await createCoinCall(call);
  const { request } = await publicClient.simulateContract({
    ...createCoinRequest,
    account: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _6 => _6.account]), () => ( walletClient.account))
  });
  if (request.gas) {
    request.gas = request.gas * BigInt(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _7 => _7.gasMultiplier]), () => ( 100))) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: _optionalChain([deployment, 'optionalAccess', _8 => _8.coin]),
    deployment,
    chain: getChainFromId(publicClient.chain.id)
  };
}

// src/actions/getOnchainCoinDetails.ts


async function getOnchainCoinDetails({
  coin,
  user = _viem.zeroAddress,
  publicClient
}) {
  validateClientNetwork(publicClient);
  const [balance, owners, payoutRecipient] = await publicClient.multicall({
    contracts: [
      {
        address: coin,
        abi: _protocoldeployments.coinABI,
        functionName: "balanceOf",
        args: [user]
      },
      {
        address: coin,
        abi: _protocoldeployments.coinABI,
        functionName: "owners"
      },
      {
        address: coin,
        abi: _protocoldeployments.coinABI,
        functionName: "payoutRecipient"
      }
    ],
    allowFailure: false
  });
  return {
    balance,
    owners,
    payoutRecipient
  };
}

// src/actions/updateCoinURI.ts




function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: _protocoldeployments.coinABI,
    address: coin,
    functionName: "setContractURI",
    args: [newURI],
    dataSuffix: getAttribution()
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = _viem.parseEventLogs.call(void 0, { abi: _protocoldeployments.coinABI, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts




function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: _protocoldeployments.coinABI,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient],
    dataSuffix: getAttribution()
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = _viem.parseEventLogs.call(void 0, { abi: _protocoldeployments.coinABI, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/actions/tradeCoin.ts







// src/client/client.gen.ts



var _clientfetch = require('@hey-api/client-fetch');
var client = _clientfetch.createClient.call(void 0, 
  _clientfetch.createConfig.call(void 0, {
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinComments",
    ...options
  });
};
var getCoinHolders = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinHolders",
    ...options
  });
};
var getCoinSwaps = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinSwaps",
    ...options
  });
};
var getCoins = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coins",
    ...options
  });
};
var setCreateUploadJwt = (options) => {
  return (_nullishCoalesce(_optionalChain([options, 'optionalAccess', _9 => _9.client]), () => ( client))).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/createUploadJWT",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ..._optionalChain([options, 'optionalAccess', _10 => _10.headers])
    }
  });
};
var getExplore = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileBalances",
    ...options
  });
};
var getProfileCoins = (options) => {
  return (_nullishCoalesce(options.client, () => ( client))).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileCoins",
    ...options
  });
};
var postQuote = (options) => {
  return (_nullishCoalesce(_optionalChain([options, 'optionalAccess', _11 => _11.client]), () => ( client))).post({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/quote",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ..._optionalChain([options, 'optionalAccess', _12 => _12.headers])
    }
  });
};

// src/actions/tradeCoin.ts
function convertBigIntToString(permit) {
  return {
    ...permit,
    details: {
      ...permit.details,
      amount: `${permit.details.amount}`
    },
    sigDeadline: `${permit.sigDeadline}`
  };
}
var PERMIT_SINGLE_TYPES = {
  PermitSingle: [
    { name: "details", type: "PermitDetails" },
    { name: "spender", type: "address" },
    { name: "sigDeadline", type: "uint256" }
  ],
  PermitDetails: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint160" },
    { name: "expiration", type: "uint48" },
    { name: "nonce", type: "uint48" }
  ]
};
async function tradeCoin({
  tradeParameters,
  walletClient,
  account,
  publicClient,
  validateTransaction = true
}) {
  const quote = await createTradeCall(tradeParameters);
  if (!account) {
    account = walletClient.account;
  }
  if (!account) {
    throw new Error("Account is required");
  }
  if (!tradeParameters.recipient) {
    tradeParameters.recipient = typeof account === "string" ? account : account.address;
  }
  const signatures = [];
  if (quote.permits) {
    for (const permit of quote.permits) {
      const [, , nonce] = await publicClient.readContract({
        abi: _protocoldeployments.permit2ABI,
        address: _protocoldeployments.permit2Address[_chains.base.id],
        functionName: "allowance",
        args: [
          permit.permit.details.token,
          typeof account === "string" ? account : account.address,
          permit.permit.spender
        ]
      });
      const permitToken = permit.permit.details.token;
      const allowance = await publicClient.readContract({
        abi: _viem.erc20Abi,
        address: permitToken,
        functionName: "allowance",
        args: [
          typeof account === "string" ? account : account.address,
          _protocoldeployments.permit2Address[_chains.base.id]
        ]
      });
      if (allowance < BigInt(permit.permit.details.amount)) {
        const approvalTx = await walletClient.writeContract({
          abi: _viem.erc20Abi,
          address: permitToken,
          functionName: "approve",
          chain: _chains.base,
          args: [_protocoldeployments.permit2Address[_chains.base.id], _viem.maxUint256],
          account
        });
        await publicClient.waitForTransactionReceipt({
          hash: approvalTx
        });
      }
      const message = {
        details: {
          token: permit.permit.details.token,
          amount: BigInt(permit.permit.details.amount),
          expiration: Number(permit.permit.details.expiration),
          nonce
        },
        spender: permit.permit.spender,
        sigDeadline: BigInt(permit.permit.sigDeadline)
      };
      const signature = await walletClient.signTypedData({
        domain: {
          name: "Permit2",
          chainId: _chains.base.id,
          verifyingContract: _protocoldeployments.permit2Address[_chains.base.id]
        },
        primaryType: "PermitSingle",
        types: PERMIT_SINGLE_TYPES,
        message,
        account: typeof account === "string" ? account : account.address
      });
      signatures.push({
        signature,
        permit: convertBigIntToString(message)
      });
    }
  }
  const newQuote = await createTradeCall({
    ...tradeParameters,
    signatures
  });
  const call = {
    to: newQuote.call.target,
    data: newQuote.call.data,
    value: BigInt(newQuote.call.value),
    chain: _chains.base,
    account
  };
  if (validateTransaction) {
    await publicClient.call(call);
  }
  const gasEstimate = validateTransaction ? await publicClient.estimateGas(call) : 10000000n;
  const gasPrice = await publicClient.getGasPrice();
  const tx = await walletClient.sendTransaction({
    ...call,
    gasPrice,
    gas: gasEstimate
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: tx
  });
  return receipt;
}
async function createTradeCall(tradeParameters) {
  if (tradeParameters.slippage && tradeParameters.slippage > 1) {
    throw new Error("Slippage must be less than 1, max 0.99");
  }
  if (tradeParameters.amountIn === BigInt(0)) {
    throw new Error("Amount in must be greater than 0");
  }
  const quote = await postQuote({
    body: {
      tokenIn: tradeParameters.sell,
      tokenOut: tradeParameters.buy,
      amountIn: tradeParameters.amountIn.toString(),
      slippage: tradeParameters.slippage,
      chainId: _chains.base.id,
      sender: tradeParameters.sender,
      recipient: tradeParameters.recipient || tradeParameters.sender,
      signatures: tradeParameters.signatures
    }
  });
  if (!quote.data) {
    console.error(quote);
    throw new Error("Quote failed");
  }
  return quote.data;
}

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKey() {
  return apiKey;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    ...getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinHolders2 = async (query, options) => {
  return await getCoinHolders({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinSwaps2 = async (query, options) => {
  return await getCoinSwaps({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileCoins2 = async (query, options) => {
  return await getProfileCoins({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  ...getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
var getCreatorCoins = (query = {}, options) => createExploreQuery(query, "NEW_CREATORS", options);
var getMostValuableCreatorCoins = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE_CREATORS", options);

// src/uploader/metadata.ts
function validateImageMimeType(mimeType) {
  if (![
    "image/png",
    "image/jpeg",
    "image/jpg",
    "image/gif",
    "image/svg+xml"
  ].includes(mimeType)) {
    throw new Error("Image must be a PNG, JPEG, JPG, GIF or SVG");
  }
}
function getURLFromUploadResult(uploadResult) {
  return new URL(uploadResult.url);
}
var CoinMetadataBuilder = class {
  withName(name) {
    this.name = name;
    if (typeof name !== "string") {
      throw new Error("Name must be a string");
    }
    return this;
  }
  withSymbol(symbol) {
    this.symbol = symbol;
    if (typeof symbol !== "string") {
      throw new Error("Symbol must be a string");
    }
    return this;
  }
  withDescription(description) {
    this.description = description;
    if (typeof description !== "string") {
      throw new Error("Description must be a string");
    }
    return this;
  }
  withImage(image) {
    if (this.imageURL) {
      throw new Error("Image URL already set");
    }
    if (!(image instanceof File)) {
      throw new Error("Image must be a File");
    }
    validateImageMimeType(image.type);
    this.imageFile = image;
    return this;
  }
  withImageURI(imageURI) {
    if (this.imageFile) {
      throw new Error("Image file already set");
    }
    if (typeof imageURI !== "string") {
      throw new Error("Image URI must be a string");
    }
    const url = new URL(imageURI);
    this.imageURL = url;
    return this;
  }
  withProperties(properties) {
    for (const [key, value] of Object.entries(properties)) {
      if (typeof key !== "string") {
        throw new Error("Property key must be a string");
      }
      if (typeof value !== "string") {
        throw new Error("Property value must be a string");
      }
    }
    if (!this.properties) {
      this.properties = {};
    }
    this.properties = { ...this.properties, ...properties };
    return this;
  }
  withMedia(media) {
    if (this.mediaURL) {
      throw new Error("Media URL already set");
    }
    if (!(media instanceof File)) {
      throw new Error("Media must be a File");
    }
    this.mediaMimeType = media.type;
    this.mediaFile = media;
    return this;
  }
  withMediaURI(mediaURI, mediaMimeType) {
    if (this.mediaFile) {
      throw new Error("Media file already set");
    }
    if (typeof mediaURI !== "string") {
      throw new Error("Media URI must be a string");
    }
    const url = new URL(mediaURI);
    this.mediaURL = url;
    this.mediaMimeType = mediaMimeType;
    return this;
  }
  validate() {
    if (!this.name) {
      throw new Error("Name is required");
    }
    if (!this.symbol) {
      throw new Error("Symbol is required");
    }
    if (!this.imageFile && !this.imageURL) {
      throw new Error("Image is required");
    }
    return this;
  }
  generateMetadata() {
    return {
      name: this.name,
      symbol: this.symbol,
      description: this.description,
      image: this.imageURL.toString(),
      animation_url: _optionalChain([this, 'access', _13 => _13.mediaURL, 'optionalAccess', _14 => _14.toString, 'call', _15 => _15()]),
      content: this.mediaURL ? {
        uri: _optionalChain([this, 'access', _16 => _16.mediaURL, 'optionalAccess', _17 => _17.toString, 'call', _18 => _18()]),
        mime: this.mediaMimeType
      } : void 0,
      properties: this.properties
    };
  }
  async upload(uploader) {
    this.validate();
    if (this.imageFile) {
      const uploadResult2 = await uploader.upload(this.imageFile);
      this.imageURL = getURLFromUploadResult(uploadResult2);
    }
    if (this.mediaFile) {
      const uploadResult2 = await uploader.upload(this.mediaFile);
      this.mediaURL = getURLFromUploadResult(uploadResult2);
    }
    const metadata = this.generateMetadata();
    const uploadResult = await uploader.upload(
      new File([JSON.stringify(metadata)], "metadata.json", {
        type: "application/json"
      })
    );
    return {
      url: getURLFromUploadResult(uploadResult).toString(),
      createMetadataParameters: {
        name: this.name,
        symbol: this.symbol,
        uri: uploadResult.url
      },
      metadata
    };
  }
};
function createMetadataBuilder() {
  return new CoinMetadataBuilder();
}

// src/api/internal.ts
var setCreateUploadJwt2 = async (body, options) => {
  return await setCreateUploadJwt({
    body,
    ...getApiKeyMeta(),
    ...options
  });
};

// src/uploader/providers/zora.ts
var ZoraUploader = class {
  constructor(creatorAddress) {
    this.creatorAddress = creatorAddress;
    if (!getApiKey()) {
      throw new Error("API key is required for metadata interactions");
    }
  }
  async getJWTApiKey() {
    if (this.jwtApiKey && this.jwtApiKeyExpiresAt && this.jwtApiKeyExpiresAt > Date.now()) {
      return this.jwtApiKey;
    }
    this.jwtApiKeyExpiresAt = Date.now() + 1e3 * 60 * 60;
    const response = await setCreateUploadJwt2({
      creatorAddress: this.creatorAddress
    });
    this.jwtApiKey = _optionalChain([response, 'access', _19 => _19.data, 'optionalAccess', _20 => _20.createUploadJwtFromApiKey]);
    if (!this.jwtApiKey) {
      throw new Error("Failed to create upload JWT");
    }
    return this.jwtApiKey;
  }
  async upload(file) {
    const jwtApiKey = await this.getJWTApiKey();
    const formData = new FormData();
    formData.append("file", file, file.name);
    const response = await fetch(
      "https://ipfs-uploader.zora.co/api/v0/add?cid-version=1",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${jwtApiKey}`,
          Accept: "*/*"
        },
        body: formData
      }
    );
    if (!response.ok) {
      console.error(await response.text());
      throw new Error(`Failed to upload file: ${response.statusText}`);
    }
    const data = await response.json();
    return {
      url: `ipfs://${data.cid}`,
      size: data.size,
      mimeType: data.mimeType
    };
  }
};
function createZoraUploaderForCreator(creatorAddress) {
  return new ZoraUploader(creatorAddress);
}







































exports.CoinMetadataBuilder = CoinMetadataBuilder; exports.DeployCurrency = DeployCurrency; exports.InitialPurchaseCurrency = InitialPurchaseCurrency; exports.ZoraUploader = ZoraUploader; exports.cleanAndValidateMetadataURI = cleanAndValidateMetadataURI; exports.createCoin = createCoin; exports.createCoinCall = createCoinCall; exports.createMetadataBuilder = createMetadataBuilder; exports.createTradeCall = createTradeCall; exports.createZoraUploaderForCreator = createZoraUploaderForCreator; exports.getCoin = getCoin2; exports.getCoinComments = getCoinComments2; exports.getCoinCreateFromLogs = getCoinCreateFromLogs; exports.getCoinHolders = getCoinHolders2; exports.getCoinSwaps = getCoinSwaps2; exports.getCoins = getCoins2; exports.getCoinsLastTraded = getCoinsLastTraded; exports.getCoinsLastTradedUnique = getCoinsLastTradedUnique; exports.getCoinsMostValuable = getCoinsMostValuable; exports.getCoinsNew = getCoinsNew; exports.getCoinsTopGainers = getCoinsTopGainers; exports.getCoinsTopVolume24h = getCoinsTopVolume24h; exports.getCreatorCoins = getCreatorCoins; exports.getMostValuableCreatorCoins = getMostValuableCreatorCoins; exports.getOnchainCoinDetails = getOnchainCoinDetails; exports.getProfile = getProfile2; exports.getProfileBalances = getProfileBalances2; exports.getProfileCoins = getProfileCoins2; exports.getURLFromUploadResult = getURLFromUploadResult; exports.setApiKey = setApiKey; exports.tradeCoin = tradeCoin; exports.updateCoinURI = updateCoinURI; exports.updateCoinURICall = updateCoinURICall; exports.updatePayoutRecipient = updatePayoutRecipient; exports.updatePayoutRecipientCall = updatePayoutRecipientCall; exports.validateImageMimeType = validateImageMimeType; exports.validateMetadataJSON = validateMetadataJSON; exports.validateMetadataURIContent = validateMetadataURIContent;
//# sourceMappingURL=index.cjs.map