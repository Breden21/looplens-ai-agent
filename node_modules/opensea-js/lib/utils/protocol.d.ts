import { Seaport } from "@opensea/seaport-js";
import { ItemType } from "@opensea/seaport-js/lib/constants";
import { TokenStandard } from "../types";
/**
 * Gets the appropriate ItemType for a given token standard.
 * @param tokenStandard The token standard (ERC20, ERC721, ERC1155)
 * @returns The corresponding ItemType from Seaport
 */
export declare const getAssetItemType: (tokenStandard: TokenStandard) => ItemType.ERC20 | ItemType.ERC721 | ItemType.ERC1155;
/**
 * Checks if the token address is the shared storefront address and if so replaces
 * that address with the lazy mint adapter address. Otherwise, returns the input token address
 * @param tokenAddress token address
 * @returns input token address or lazy mint adapter address
 */
export declare const getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress: (tokenAddress: string) => string;
/**
 * Returns if a protocol address is valid.
 * @param protocolAddress The protocol address
 */
export declare const isValidProtocol: (protocolAddress: string) => boolean;
/**
 * Throws an error if the protocol address is not valid.
 * @param protocolAddress The protocol address
 */
export declare const requireValidProtocol: (protocolAddress: string) => void;
/**
 * Get the Seaport instance for a given protocol address.
 * This is a shared utility to avoid duplicating the logic across multiple SDK manager classes.
 * @param protocolAddress The protocol address
 * @param seaport The Seaport instance
 * @returns The Seaport instance for the given protocol address
 * @throws Error if the protocol address is not supported
 */
export declare const getSeaportInstance: (protocolAddress: string, seaport: Seaport) => Seaport;
/**
 * Get the Seaport version string for a given protocol address.
 * @param protocolAddress The protocol address
 * @returns The version string (e.g., "1.6")
 * @throws Error if the protocol address is not supported
 */
export declare const getSeaportVersion: (protocolAddress: string) => string;
/**
 * Decodes an encoded string of token IDs into an array of individual token IDs using bigint for precise calculations.
 *
 * The encoded token IDs can be in the following formats:
 * 1. Single numbers: '123' => ['123']
 * 2. Comma-separated numbers: '1,2,3,4' => ['1', '2', '3', '4']
 * 3. Ranges of numbers: '5:8' => ['5', '6', '7', '8']
 * 4. Combinations of single numbers and ranges: '1,3:5,8' => ['1', '3', '4', '5', '8']
 * 5. Wildcard '*' (matches all token IDs): '*' => ['*']
 *
 * @param encodedTokenIds - The encoded string of token IDs to be decoded.
 * @returns An array of individual token IDs after decoding the input.
 *
 * @throws {Error} If the input is not correctly formatted or if bigint operations fail.
 *
 * @example
 * const encoded = '1,3:5,8';
 * const decoded = decodeTokenIds(encoded); // Output: ['1', '3', '4', '5', '8']
 *
 * @example
 * const encodedWildcard = '*';
 * const decodedWildcard = decodeTokenIds(encodedWildcard); // Output: ['*']
 *
 * @example
 * const emptyEncoded = '';
 * const decodedEmpty = decodeTokenIds(emptyEncoded); // Output: []
 */
export declare const decodeTokenIds: (encodedTokenIds: string) => string[];
