"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrdersAPI = void 0;
const apiPaths_1 = require("./apiPaths");
const utils_1 = require("../orders/utils");
const types_1 = require("../types");
/**
 * Order-related API operations
 */
class OrdersAPI {
    constructor(get, post, chain) {
        this.get = get;
        this.post = post;
        this.chain = chain;
    }
    /**
     * Gets an order from API based on query options.
     */
    async getOrder({ side, protocol = "seaport", orderDirection = "desc", orderBy = "created_date", ...restOptions }) {
        // Validate eth_price orderBy requires additional parameters
        if (orderBy === "eth_price") {
            if (!restOptions.assetContractAddress ||
                !restOptions.tokenIds ||
                restOptions.tokenIds.length === 0) {
                throw new Error('When using orderBy: "eth_price", you must provide both asset_contract_address and token_ids parameters');
            }
        }
        const { orders } = await this.get((0, apiPaths_1.getOrdersAPIPath)(this.chain, protocol, side), (0, utils_1.serializeOrdersQueryOptions)({
            limit: 1,
            orderBy,
            orderDirection,
            ...restOptions,
        }));
        if (orders.length === 0) {
            throw new Error("Not found: no matching order found");
        }
        return (0, utils_1.deserializeOrder)(orders[0]);
    }
    /**
     * Gets a single order by its order hash.
     */
    async getOrderByHash(orderHash, protocolAddress, chain = this.chain) {
        const response = await this.get((0, apiPaths_1.getOrderByHashPath)(chain, protocolAddress, orderHash));
        return (0, utils_1.deserializeOrder)(response.order);
    }
    /**
     * Gets a list of orders from API based on query options.
     */
    async getOrders({ side, protocol = "seaport", orderDirection = "desc", orderBy = "created_date", pageSize = 20, ...restOptions }) {
        // Validate eth_price orderBy requires additional parameters
        if (orderBy === "eth_price") {
            if (!restOptions.assetContractAddress ||
                !restOptions.tokenIds ||
                restOptions.tokenIds.length === 0) {
                throw new Error('When using orderBy: "eth_price", you must provide both asset_contract_address and token_ids parameters');
            }
        }
        const response = await this.get((0, apiPaths_1.getOrdersAPIPath)(this.chain, protocol, side), (0, utils_1.serializeOrdersQueryOptions)({
            limit: pageSize,
            orderBy,
            orderDirection,
            ...restOptions,
        }));
        return {
            ...response,
            orders: response.orders.map(utils_1.deserializeOrder),
        };
    }
    /**
     * Generate the data needed to fulfill a listing or an offer onchain.
     */
    async generateFulfillmentData(fulfillerAddress, orderHash, protocolAddress, side, assetContractAddress, tokenId) {
        let payload = null;
        if (side === types_1.OrderSide.LISTING) {
            payload = (0, utils_1.getFulfillListingPayload)(fulfillerAddress, orderHash, protocolAddress, this.chain, assetContractAddress, tokenId);
        }
        else {
            payload = (0, utils_1.getFulfillOfferPayload)(fulfillerAddress, orderHash, protocolAddress, this.chain, assetContractAddress, tokenId);
        }
        const response = await this.post((0, utils_1.getFulfillmentDataPath)(side), payload);
        return response;
    }
    /**
     * Post an order to OpenSea.
     */
    async postOrder(order, apiOptions) {
        const { protocol = "seaport", side, protocolAddress } = apiOptions;
        // Validate required fields
        if (!side) {
            throw new Error("apiOptions.side is required");
        }
        if (!protocolAddress) {
            throw new Error("apiOptions.protocolAddress is required");
        }
        if (!order) {
            throw new Error("order data is required");
        }
        // Validate protocol value
        if (protocol !== "seaport") {
            throw new Error("Currently only 'seaport' protocol is supported");
        }
        // Validate side value
        if (side !== "ask" && side !== "bid") {
            throw new Error("side must be either 'ask' or 'bid'");
        }
        // Validate protocolAddress format
        if (!/^0x[a-fA-F0-9]{40}$/.test(protocolAddress)) {
            throw new Error("Invalid protocol address format");
        }
        const response = await this.post((0, apiPaths_1.getOrdersAPIPath)(this.chain, protocol, side), { ...order, protocol_address: protocolAddress });
        return (0, utils_1.deserializeOrder)(response.order);
    }
    /**
     * Offchain cancel an order, offer or listing, by its order hash when protected by the SignedZone.
     */
    async offchainCancelOrder(protocolAddress, orderHash, chain = this.chain, offererSignature) {
        const response = await this.post((0, apiPaths_1.getCancelOrderPath)(chain, protocolAddress, orderHash), { offererSignature });
        return response;
    }
}
exports.OrdersAPI = OrdersAPI;
//# sourceMappingURL=orders.js.map