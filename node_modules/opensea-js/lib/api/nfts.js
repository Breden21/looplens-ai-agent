"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTsAPI = void 0;
const apiPaths_1 = require("./apiPaths");
/**
 * NFT-related API operations
 */
class NFTsAPI {
    constructor(get, post, chain) {
        this.get = get;
        this.post = post;
        this.chain = chain;
    }
    /**
     * Fetch multiple NFTs for a collection.
     */
    async getNFTsByCollection(slug, limit = undefined, next = undefined) {
        const response = await this.get((0, apiPaths_1.getListNFTsByCollectionPath)(slug), {
            limit,
            next,
        });
        return response;
    }
    /**
     * Fetch multiple NFTs for a contract.
     */
    async getNFTsByContract(address, limit = undefined, next = undefined, chain = this.chain) {
        const response = await this.get((0, apiPaths_1.getListNFTsByContractPath)(chain, address), {
            limit,
            next,
        });
        return response;
    }
    /**
     * Fetch NFTs owned by an account.
     */
    async getNFTsByAccount(address, limit = undefined, next = undefined, chain = this.chain) {
        const response = await this.get((0, apiPaths_1.getListNFTsByAccountPath)(chain, address), {
            limit,
            next,
        });
        return response;
    }
    /**
     * Fetch metadata, traits, ownership information, and rarity for a single NFT.
     */
    async getNFT(address, identifier, chain = this.chain) {
        const response = await this.get((0, apiPaths_1.getNFTPath)(chain, address, identifier));
        return response;
    }
    /**
     * Force refresh the metadata for an NFT.
     */
    async refreshNFTMetadata(address, identifier, chain = this.chain) {
        const response = await this.post((0, apiPaths_1.getRefreshMetadataPath)(chain, address, identifier), {});
        return response;
    }
}
exports.NFTsAPI = NFTsAPI;
//# sourceMappingURL=nfts.js.map