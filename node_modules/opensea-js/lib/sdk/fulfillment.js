"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FulfillmentManager = void 0;
const privateListings_1 = require("../orders/privateListings");
const types_1 = require("../orders/types");
const utils_1 = require("../orders/utils");
const types_2 = require("../types");
const utils_2 = require("../utils/utils");
/**
 * Manager for order fulfillment and validation operations.
 * Handles fulfilling orders, validating orders onchain, and approving orders.
 */
class FulfillmentManager {
    constructor(context, ordersManager) {
        this.context = context;
        this.ordersManager = ordersManager;
    }
    /**
     * Fulfill a private order for a designated address.
     * @param options
     * @param options.order The order to fulfill
     * @param options.accountAddress Address of the wallet taking the order.
     * @param options.domain An optional domain to be hashed and included at the end of fulfillment calldata.
     *                       This can be used for on-chain order attribution to assist with analytics.
     * @param options.overrides Transaction overrides, ignored if not set.
     * @returns Transaction hash of the order.
     */
    async fulfillPrivateOrder({ order, accountAddress, domain, overrides, }) {
        if (!order.taker?.address) {
            throw new Error("Order is not a private listing - must have a taker address");
        }
        const counterOrder = (0, privateListings_1.constructPrivateListingCounterOrder)(order.protocolData, order.taker.address);
        const fulfillments = (0, privateListings_1.getPrivateListingFulfillments)(order.protocolData);
        const seaport = (0, utils_2.getSeaportInstance)(order.protocolAddress, this.context.seaport);
        const transaction = await seaport
            .matchOrders({
            orders: [order.protocolData, counterOrder],
            fulfillments,
            overrides: {
                ...overrides,
                value: counterOrder.parameters.offer[0].startAmount,
            },
            accountAddress,
            domain,
        })
            .transact();
        const transactionReceipt = await transaction.wait();
        if (!transactionReceipt) {
            throw new Error("Missing transaction receipt");
        }
        await this.context.confirmTransaction(transactionReceipt.hash, types_2.EventType.MatchOrders, "Fulfilling order");
        return transactionReceipt.hash;
    }
    /**
     * Fulfill an order for an asset. The order can be either a listing or an offer.
     * @param options
     * @param options.order The order to fulfill, a.k.a. "take"
     * @param options.accountAddress Address of the wallet taking the offer.
     * @param options.recipientAddress The optional address to receive the order's item(s) or currencies. If not specified, defaults to accountAddress.
     * @param options.domain An optional domain to be hashed and included at the end of fulfillment calldata.  This can be used for on-chain order attribution to assist with analytics.
     * @param options.assetContractAddress Optional address of the NFT contract for criteria offers (e.g., collection offers). Required when fulfilling collection offers.
     * @param options.tokenId Optional token ID for criteria offers (e.g., collection offers). Required when fulfilling collection offers.
     * @param options.overrides Transaction overrides, ignored if not set.
     * @returns Transaction hash of the order.
     *
     * @throws Error if the accountAddress is not available through wallet or provider.
     * @throws Error if the order's protocol address is not supported by OpenSea. See {@link isValidProtocol}.
     * @throws Error if attempting to fulfill the order with a recipient address which does not match a private listing.
     */
    async fulfillOrder({ order, accountAddress, recipientAddress, unitsToFill, domain, assetContractAddress, tokenId, overrides, }) {
        await this.context.requireAccountIsAvailable(accountAddress);
        const protocolAddress = order.protocolAddress ?? order.protocol_address;
        (0, utils_2.requireValidProtocol)(protocolAddress);
        const orderHash = order.orderHash ?? order.order_hash;
        const side = order.side ??
            ("type" in order &&
                [types_1.OrderType.BASIC, types_1.OrderType.ENGLISH].includes(order.type)
                ? types_2.OrderSide.LISTING
                : types_2.OrderSide.OFFER);
        let extraData = undefined;
        const protocolData = order.protocolData ?? order.protocol_data;
        if (orderHash) {
            const result = await this.context.api.generateFulfillmentData(accountAddress, orderHash, protocolAddress, side, assetContractAddress, tokenId);
            // If the order is using offer protection, the extraData
            // must be included with the order to successfully fulfill.
            const inputData = result.fulfillment_data.transaction.input_data;
            if ("orders" in inputData && "extraData" in inputData.orders[0]) {
                extraData = inputData.orders[0].extraData;
            }
            const signature = result.fulfillment_data.orders[0].signature;
            protocolData.signature = signature;
        }
        const isPrivateListing = "taker" in order ? !!order.taker : false;
        if (isPrivateListing) {
            if (recipientAddress) {
                throw new Error("Private listings cannot be fulfilled with a recipient address");
            }
            return this.fulfillPrivateOrder({
                order: order,
                accountAddress,
                domain,
                overrides,
            });
        }
        // If unitsToFill is not explicitly provided, default to remaining_quantity when available
        // This prevents errors when trying to fulfill more than what's available in partially filled orders
        let effectiveUnitsToFill = unitsToFill;
        if (effectiveUnitsToFill === undefined) {
            if ("remaining_quantity" in order &&
                order.remaining_quantity !== undefined) {
                // For Listing type (API response)
                effectiveUnitsToFill = order.remaining_quantity;
            }
            else if ("remainingQuantity" in order &&
                order.remainingQuantity !== undefined) {
                // For OrderV2 type
                effectiveUnitsToFill = order.remainingQuantity;
            }
        }
        const seaport = (0, utils_2.getSeaportInstance)(protocolAddress, this.context.seaport);
        const { executeAllActions } = await seaport.fulfillOrder({
            order: protocolData,
            accountAddress,
            recipientAddress,
            unitsToFill: effectiveUnitsToFill,
            extraData,
            domain,
            overrides,
        });
        const result = (await executeAllActions());
        const transactionHash = typeof result === "string" ? result : result.hash;
        await this.context.confirmTransaction(transactionHash, types_2.EventType.MatchOrders, "Fulfilling order");
        return transactionHash;
    }
    /**
     * Returns whether an order is fulfillable.
     * An order may not be fulfillable if a target item's transfer function
     * is locked for some reason, e.g. an item is being rented within a game
     * or trading has been locked for an item type.
     * @param options
     * @param options.order Order to check
     * @param options.accountAddress The account address that will be fulfilling the order
     * @returns True if the order is fulfillable, else False.
     *
     * @throws Error if the order's protocol address is not supported by OpenSea. See {@link isValidProtocol}.
     */
    async isOrderFulfillable({ order, accountAddress, }) {
        (0, utils_2.requireValidProtocol)(order.protocolAddress);
        const seaport = (0, utils_2.getSeaportInstance)(order.protocolAddress, this.context.seaport);
        try {
            const isValid = await seaport
                .validate([order.protocolData], accountAddress)
                .staticCall();
            return !!isValid;
        }
        catch (error) {
            if ((0, utils_2.hasErrorCode)(error) && error.code === "CALL_EXCEPTION") {
                return false;
            }
            throw error;
        }
    }
    /**
     * Instead of signing an off-chain order, this methods allows you to approve an order
     * with an on-chain transaction.
     * @param order Order to approve
     * @param domain An optional domain to be hashed and included at the end of fulfillment calldata.  This can be used for on-chain order attribution to assist with analytics.
     * @returns Transaction hash of the approval transaction
     *
     * @throws Error if the accountAddress is not available through wallet or provider.
     * @throws Error if the order's protocol address is not supported by OpenSea. See {@link isValidProtocol}.
     */
    async approveOrder(order, domain) {
        await this.context.requireAccountIsAvailable(order.maker.address);
        (0, utils_2.requireValidProtocol)(order.protocolAddress);
        this.context.dispatch(types_2.EventType.ApproveOrder, {
            orderV2: order,
            accountAddress: order.maker.address,
        });
        const seaport = (0, utils_2.getSeaportInstance)(order.protocolAddress, this.context.seaport);
        const transaction = await seaport
            .validate([order.protocolData], order.maker.address, domain)
            .transact();
        await this.context.confirmTransaction(transaction.hash, types_2.EventType.ApproveOrder, "Approving order");
        return transaction.hash;
    }
    /**
     * Validates an order onchain using Seaport's validate() method. This submits the order onchain
     * and pre-validates the order using Seaport, which makes it cheaper to fulfill since a signature
     * is not needed to be verified during fulfillment for the order, but is not strictly required
     * and the alternative is orders can be submitted to the API for free instead of sent onchain.
     * @param orderComponents Order components to validate onchain
     * @param accountAddress Address of the wallet that will pay the gas to validate the order
     * @returns Transaction hash of the validation transaction
     *
     * @throws Error if the accountAddress is not available through wallet or provider.
     */
    async validateOrderOnchain(orderComponents, accountAddress) {
        await this.context.requireAccountIsAvailable(accountAddress);
        this.context.dispatch(types_2.EventType.ApproveOrder, {
            orderV2: { protocolData: orderComponents },
            accountAddress,
        });
        const seaport = (0, utils_2.getSeaportInstance)(utils_1.DEFAULT_SEAPORT_CONTRACT_ADDRESS, this.context.seaport);
        const transaction = await seaport
            .validate([{ parameters: orderComponents, signature: "0x" }], accountAddress)
            .transact();
        await this.context.confirmTransaction(transaction.hash, types_2.EventType.ApproveOrder, "Validating order onchain");
        return transaction.hash;
    }
    /**
     * Create and validate a listing onchain using Seaport's validate() method. This combines
     * order building with onchain validation in a single call.
     * @param options Listing parameters
     * @returns Transaction hash of the validation transaction
     */
    async createListingAndValidateOnchain({ asset, accountAddress, startAmount, endAmount, quantity = 1, domain, salt, listingTime, expirationTime, paymentTokenAddress, buyerAddress, englishAuction, includeOptionalCreatorFees = false, zone, }) {
        const orderComponents = await this.ordersManager.buildListingOrderComponents({
            asset,
            accountAddress,
            startAmount,
            endAmount,
            quantity,
            domain,
            salt,
            listingTime,
            expirationTime,
            paymentTokenAddress,
            buyerAddress,
            englishAuction,
            includeOptionalCreatorFees,
            zone,
        });
        return this.validateOrderOnchain(orderComponents, accountAddress);
    }
    /**
     * Create and validate an offer onchain using Seaport's validate() method. This combines
     * order building with onchain validation in a single call.
     * @param options Offer parameters
     * @returns Transaction hash of the validation transaction
     */
    async createOfferAndValidateOnchain({ asset, accountAddress, startAmount, quantity = 1, domain, salt, expirationTime, paymentTokenAddress, zone, }) {
        const orderComponents = await this.ordersManager.buildOfferOrderComponents({
            asset,
            accountAddress,
            startAmount,
            quantity,
            domain,
            salt,
            expirationTime,
            paymentTokenAddress,
            zone,
        });
        return this.validateOrderOnchain(orderComponents, accountAddress);
    }
}
exports.FulfillmentManager = FulfillmentManager;
//# sourceMappingURL=fulfillment.js.map