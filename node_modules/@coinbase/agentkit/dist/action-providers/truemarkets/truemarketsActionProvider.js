"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.truemarketsActionProvider = exports.TrueMarketsActionProvider = void 0;
const zod_1 = require("zod");
const actionProvider_1 = require("../actionProvider");
const actionDecorator_1 = require("../actionDecorator");
const schemas_1 = require("./schemas");
const constants_1 = require("./constants");
const viem_1 = require("viem");
const wallet_providers_1 = require("../../wallet-providers");
const viem_2 = require("viem");
/**
 * Action provider for TrueMarkets interactions.
 */
class TrueMarketsActionProvider extends actionProvider_1.ActionProvider {
    /**
     * Creates a new TrueMarkets action provider.
     */
    constructor() {
        super("truemarkets", []);
        /**
         * Checks if the TrueMarkets action provider supports the given network.
         * Currently only supports Base mainnet.
         *
         * @param network - The network to check.
         * @returns True if the TrueMarkets action provider supports the network, false otherwise.
         */
        this.supportsNetwork = (network) => network.networkId === "base-mainnet";
    }
    /**
     * Gets active markets from the TruthMarketManager contract.
     *
     * @param walletProvider - The wallet provider to use for contract interactions.
     * @param args - The input arguments for the action, including pagination and sorting options.
     * @returns JSON object containing the active markets information.
     */
    async getPredictionMarkets(walletProvider, args) {
        try {
            const limit = args.limit;
            const offset = args.offset;
            const sortOrder = args.sortOrder;
            // Get total number of markets
            const numMarkets = await walletProvider.readContract({
                address: constants_1.TruthMarketManager_ADDRESS,
                abi: constants_1.TruthMarketManagerABI,
                functionName: "numberOfActiveMarkets",
            });
            if (numMarkets === 0n) {
                return JSON.stringify({
                    success: true,
                    totalMarkets: 0,
                    markets: [],
                });
            }
            const totalMarkets = Number(numMarkets);
            const adjustedOffset = Math.min(offset, totalMarkets - 1);
            const adjustedLimit = Math.min(limit, totalMarkets - adjustedOffset);
            // Create an array of indices to fetch based on sort order
            const indices = [];
            if (sortOrder === "desc") {
                // For descending order, start from the end
                for (let i = totalMarkets - 1 - adjustedOffset; i >= Math.max(0, totalMarkets - adjustedOffset - adjustedLimit); i--) {
                    indices.push(i);
                }
            }
            else {
                // For ascending order, start from the beginning
                for (let i = adjustedOffset; i < adjustedOffset + adjustedLimit; i++) {
                    indices.push(i);
                }
            }
            // Use multicall to fetch all market addresses in a single call
            const addressCalls = indices.map(index => ({
                address: constants_1.TruthMarketManager_ADDRESS,
                abi: constants_1.TruthMarketManagerABI,
                functionName: "getActiveMarketAddress",
                args: [BigInt(index)],
            }));
            const marketAddresses = await walletProvider.getPublicClient().multicall({
                contracts: addressCalls,
            });
            // Filter out errors and extract results
            const validAddresses = marketAddresses
                .filter(result => result.status === "success")
                .map(result => result.result);
            if (validAddresses.length === 0) {
                return JSON.stringify({
                    success: false,
                    error: "Failed to retrieve market addresses",
                });
            }
            // Use multicall to fetch all market questions in a single call
            const questionCalls = validAddresses.map(address => ({
                address,
                abi: constants_1.TruthMarketABI,
                functionName: "marketQuestion",
            }));
            const marketQuestionsResult = await walletProvider.getPublicClient().multicall({
                contracts: questionCalls,
            });
            // Create market objects mapping indices to addresses and questions
            const markets = indices
                .filter((_, idx) => idx < validAddresses.length)
                .map((id, idx) => ({
                id,
                address: validAddresses[idx],
                marketQuestion: marketQuestionsResult[idx].status === "success"
                    ? marketQuestionsResult[idx].result
                    : "Failed to retrieve question",
            }));
            return JSON.stringify({
                success: true,
                totalMarkets,
                markets,
            });
        }
        catch (error) {
            return JSON.stringify({
                success: false,
                error: `Error retrieving active markets: ${error}`,
            });
        }
    }
    /**
     * Gets detailed information for a specific market address.
     *
     * @param walletProvider - The wallet provider to use for contract interactions.
     * @param args - The input arguments for the action, containing the market address.
     * @returns JSON object containing detailed market information.
     */
    async getPredictionMarketDetails(walletProvider, args) {
        try {
            let marketAddress;
            // Check if input is an Ethereum address
            const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
            if (ethAddressRegex.test(args)) {
                marketAddress = args;
            }
            else {
                // Try to parse as market ID
                const marketId = parseInt(args, 10);
                if (isNaN(marketId) || marketId < 0) {
                    return JSON.stringify({
                        success: false,
                        error: `Invalid input: "${args}". Must be either a valid Ethereum address (0x...) or a non-negative market ID number.`,
                    });
                }
                try {
                    marketAddress = (await walletProvider.getPublicClient().readContract({
                        address: constants_1.TruthMarketManager_ADDRESS,
                        abi: constants_1.TruthMarketManagerABI,
                        functionName: "getActiveMarketAddress",
                        args: [BigInt(marketId)],
                    }));
                }
                catch (error) {
                    return JSON.stringify({
                        success: false,
                        error: `Error retrieving market address for ID ${marketId}: ${error}`,
                    });
                }
            }
            // Get basic market info using multicall
            const basicInfoCalls = [
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "marketQuestion",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "additionalInfo",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "marketSource",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "getCurrentStatus",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "endOfTrading",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "getPoolAddresses",
                },
                {
                    address: marketAddress,
                    abi: constants_1.TruthMarketABI,
                    functionName: "winningPosition",
                },
            ];
            const basicInfoResults = await walletProvider.getPublicClient().multicall({
                contracts: basicInfoCalls,
            });
            // Extract results, handling potential errors
            if (basicInfoResults.some(result => result.status === "failure")) {
                return JSON.stringify({
                    success: false,
                    error: "Error retrieving basic market information",
                });
            }
            const question = basicInfoResults[0].result;
            const additionalInfo = basicInfoResults[1].result;
            const source = basicInfoResults[2].result;
            const statusNum = basicInfoResults[3].result;
            const endOfTrading = basicInfoResults[4].result;
            const pools = basicInfoResults[5].result;
            const marketWinningPosition = Number(basicInfoResults[6].result);
            // Get pool addresses
            const [yesPool, noPool] = pools;
            // Get pool token information using multicall
            const poolInfoCalls = [
                {
                    address: yesPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "token0",
                },
                {
                    address: yesPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "token1",
                },
                {
                    address: noPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "token0",
                },
                {
                    address: noPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "token1",
                },
                {
                    address: yesPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "slot0",
                },
                {
                    address: noPool,
                    abi: constants_1.UniswapV3PoolABI,
                    functionName: "slot0",
                },
            ];
            const poolInfoResults = await walletProvider.getPublicClient().multicall({
                contracts: poolInfoCalls,
            });
            if (poolInfoResults.some(result => result.status === "failure")) {
                return JSON.stringify({
                    success: false,
                    error: "Error retrieving pool information",
                });
            }
            const yesToken0 = poolInfoResults[0].result;
            const yesToken1 = poolInfoResults[1].result;
            const noToken0 = poolInfoResults[2].result;
            const noToken1 = poolInfoResults[3].result;
            const yesSlot0 = poolInfoResults[4].result;
            const noSlot0 = poolInfoResults[5].result;
            // Determine payment token (USDC or TYD) - should be the same for both pools
            const payToken = yesToken0 === constants_1.USDC_ADDRESS || yesToken0 === constants_1.TYD_ADDRESS ? yesToken0 : yesToken1;
            // Determine which token is the YES/NO token in each pool
            const yesToken = yesToken0 === payToken ? yesToken1 : yesToken0;
            const noToken = noToken0 === payToken ? noToken1 : noToken0;
            const isYesToken0 = yesToken0 === yesToken;
            const isNoToken0 = noToken0 === noToken;
            // Extract sqrtPriceX96 from slot0 results
            const yesSqrtPriceX96 = yesSlot0[0];
            const noSqrtPriceX96 = noSlot0[0];
            // Get pool balances using multicall
            const balanceCalls = [
                {
                    address: payToken,
                    abi: viem_1.erc20Abi,
                    functionName: "balanceOf",
                    args: [yesPool],
                },
                {
                    address: yesToken,
                    abi: viem_1.erc20Abi,
                    functionName: "balanceOf",
                    args: [yesPool],
                },
                {
                    address: payToken,
                    abi: viem_1.erc20Abi,
                    functionName: "balanceOf",
                    args: [noPool],
                },
                {
                    address: noToken,
                    abi: viem_1.erc20Abi,
                    functionName: "balanceOf",
                    args: [noPool],
                },
            ];
            const balanceResults = await walletProvider.getPublicClient().multicall({
                contracts: balanceCalls,
            });
            if (balanceResults.some(result => result.status === "failure")) {
                return JSON.stringify({
                    success: false,
                    error: "Error retrieving token balances",
                });
            }
            const yesPoolStableBalance = balanceResults[0].result;
            const yesPoolTokenBalance = balanceResults[1].result;
            const noPoolStableBalance = balanceResults[2].result;
            const noPoolTokenBalance = balanceResults[3].result;
            // Calculate prices from slot0 data
            const calculatePrice = (sqrtPriceX96, isTokenZero, usdcDecimals_, tokenDecimals_) => {
                const Q96 = 2n ** 96n;
                const sqrtPrice = Number(sqrtPriceX96) / Number(Q96);
                const price = sqrtPrice * sqrtPrice;
                // Decimal adjustment between USDC and YES/NO tokens
                const decimalAdjustment = 10 ** (Number(tokenDecimals_) - Number(usdcDecimals_));
                if (isTokenZero) {
                    // If YES/NO token is token0, price = price * decimalAdjustment
                    return price * decimalAdjustment;
                }
                else {
                    // If YES/NO token is token1, price = 1/price * decimalAdjustment
                    return (1 / price) * decimalAdjustment;
                }
            };
            // Calculate TVL based on token balances and prices
            const payDecimals = payToken === constants_1.USDC_ADDRESS ? Number(constants_1.USDC_DECIMALS) : Number(constants_1.TYD_DECIMALS);
            const yesNoTokenDecimals_ = Number(constants_1.YESNO_DECIMALS);
            const yesPrice = calculatePrice(yesSqrtPriceX96, isYesToken0, payDecimals, yesNoTokenDecimals_);
            const noPrice = calculatePrice(noSqrtPriceX96, isNoToken0, payDecimals, yesNoTokenDecimals_);
            // Calculate TVL using token balances
            const yesPoolStableValue = Number((0, viem_2.formatUnits)(yesPoolStableBalance || 0n, payDecimals));
            const yesPoolTokenValue = Number((0, viem_2.formatUnits)(yesPoolTokenBalance || 0n, yesNoTokenDecimals_)) * yesPrice;
            const noPoolStableValue = Number((0, viem_2.formatUnits)(noPoolStableBalance || 0n, payDecimals));
            const noPoolTokenValue = Number((0, viem_2.formatUnits)(noPoolTokenBalance || 0n, yesNoTokenDecimals_)) * noPrice;
            const yesTVL = yesPoolStableValue + yesPoolTokenValue;
            const noTVL = noPoolStableValue + noPoolTokenValue;
            const totalTVL = yesTVL + noTVL;
            // Map winning position to string
            let winningPositionString = "Open";
            switch (marketWinningPosition) {
                case 1:
                    winningPositionString = "Yes";
                    break;
                case 2:
                    winningPositionString = "No";
                    break;
                case 3:
                    winningPositionString = "Canceled";
                    break;
                default:
                    winningPositionString = "Open";
            }
            return JSON.stringify({
                success: true,
                marketAddress,
                question,
                additionalInfo,
                source,
                status: Number(statusNum),
                resolutionTime: Number(endOfTrading),
                prices: {
                    yes: parseFloat(yesPrice.toFixed(6)),
                    no: parseFloat(noPrice.toFixed(6)),
                },
                tokens: {
                    yes: {
                        tokenAddress: yesToken,
                        lpAddress: yesPool,
                        poolSize: parseFloat(yesTVL.toFixed(2)),
                    },
                    no: {
                        tokenAddress: noToken,
                        lpAddress: noPool,
                        poolSize: parseFloat(noTVL.toFixed(2)),
                    },
                    payToken: {
                        tokenAddress: payToken,
                        tokenName: payToken === constants_1.USDC_ADDRESS ? "USDC" : "TYD",
                    },
                },
                tvl: parseFloat(totalTVL.toFixed(2)),
                winningPosition: marketWinningPosition,
                winningPositionString,
            });
        }
        catch (error) {
            return JSON.stringify({
                success: false,
                error: `Error retrieving market details: ${error}`,
            });
        }
    }
}
exports.TrueMarketsActionProvider = TrueMarketsActionProvider;
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "get_prediction_markets",
        description: `
    This tool will retrieve prediction markets from the Truemarkets platform.
    It returns a list of markets with their ID, contract address and market question.
    You can paginate results using limit and offset parameters, and sort them in ascending or descending order.
    Market IDs are sorted by their creation date, with the oldest market having ID 0.
    `,
        schema: schemas_1.GetTruthMarketsSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [wallet_providers_1.EvmWalletProvider, void 0]),
    __metadata("design:returntype", Promise)
], TrueMarketsActionProvider.prototype, "getPredictionMarkets", null);
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "get_market_details",
        description: `
    This tool will retrieve detailed information about a specific Truemarkets prediction market.
    It returns comprehensive data including market question, status, liquidity pool information, 
    prices for YES/NO tokens and Total Value Locked (TVL).
    The prices of the YES/NO token reflect the odds of the outcome.
    If the price of YES tokens is larger than of NO tokens, the market favors a YES outcome and vice versa.
    You can query using either:
    - marketAddress: The direct contract address of the market
    - id: The market ID (numeric identifier of the market)
    `,
        schema: schemas_1.GetTruthMarketDetailsSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [wallet_providers_1.EvmWalletProvider, void 0]),
    __metadata("design:returntype", Promise)
], TrueMarketsActionProvider.prototype, "getPredictionMarketDetails", null);
const truemarketsActionProvider = () => new TrueMarketsActionProvider();
exports.truemarketsActionProvider = truemarketsActionProvider;
