"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptySchema = exports.SuperfluidCreateSuperTokenSchema = exports.SuperfluidWrapTokenSchema = exports.SuperfluidUpdatePoolSchema = exports.SuperfluidCreatePoolSchema = exports.SuperfluidDeleteStreamSchema = exports.SuperfluidCreateStreamSchema = void 0;
const zod_1 = require("zod");
/**
 * Input schema for creating a Superfluid stream
 */
exports.SuperfluidCreateStreamSchema = zod_1.z
    .object({
    superTokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The ERC20 Super token to start or update streaming"),
    recipientAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The EVM address to stream the token to."),
    flowRate: zod_1.z
        .string()
        .describe("The rate at which the ERC20 is streamed to the recipient, in wei per second."),
})
    .strip()
    .describe("Input schema for creating or updating a Superfluid stream");
/**
 * Input schema for deleting a Superfluid stream
 */
exports.SuperfluidDeleteStreamSchema = zod_1.z
    .object({
    superTokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The ERC20 Super Token to start streaming"),
    recipientAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The EVM address to stream the token to."),
})
    .strip()
    .describe("Input schema for creating a Superfluid stream");
/**
 * Input schema for creating a Superfluid pool
 */
exports.SuperfluidCreatePoolSchema = zod_1.z
    .object({
    superTokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The ERC20 Super token for which to create a pool"),
})
    .strip()
    .describe("Input schema for creating a Superfluid pool");
/**
 * Input schema for updating a Superfluid pool
 */
exports.SuperfluidUpdatePoolSchema = zod_1.z
    .object({
    poolAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The EVM address of the token pool"),
    recipientAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The EVM address to stream the token to, from the pool."),
    units: zod_1.z.number().describe("The new units of the recipient in the pool."),
})
    .strip()
    .describe("Input schema for updating a Superfluid pool");
/**
 * Input schema for wrapping a Superfluid token
 */
exports.SuperfluidWrapTokenSchema = zod_1.z
    .object({
    erc20TokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The ERC20 token to wrap"),
    superTokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The token to wrap to"),
    wrapAmount: zod_1.z
        .number()
        .describe("The amount of tokens to wrap in whole units (e.g. 1.5 WETH, 10 USDC)"),
})
    .strip()
    .describe("Input schema for updating a Superfluid pool");
/**
 * Input schema for creating a Super Token
 */
exports.SuperfluidCreateSuperTokenSchema = zod_1.z
    .object({
    erc20TokenAddress: zod_1.z
        .string()
        .regex(/^0x[a-fA-F0-9]{40}$/, "Invalid Ethereum address format")
        .describe("The underlying ERC20 token"),
})
    .strip()
    .describe("Input schema for creating a Super Token");
/**
 * Empty input schema used for Query action
 */
exports.EmptySchema = zod_1.z.object({}).strip().describe("Empty input schema");
