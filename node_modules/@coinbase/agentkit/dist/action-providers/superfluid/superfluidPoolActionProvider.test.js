"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const viem_1 = require("viem");
const constants_1 = require("./constants");
const superfluidPoolActionProvider_1 = require("./superfluidPoolActionProvider");
describe("SuperfluidPoolActionProvider", () => {
    const MOCK_ADDRESS = "0xe6b2af36b3bb8d47206a129ff11d5a2de2a63c83";
    const MOCK_ERC20_CONTRACT = "0x1234567890123456789012345678901234567890";
    const MOCK_CHAIN_ID = "8453";
    let mockWallet;
    const actionProvider = (0, superfluidPoolActionProvider_1.superfluidPoolActionProvider)();
    // We'll assert on this directly (easier typing than asserting through the PublicClient type)
    let simulateContractMock;
    let mockPublicClient;
    beforeEach(() => {
        simulateContractMock = jest.fn().mockResolvedValue({
            request: {},
            result: [true, "0xDeCc403f23881285E05Df2BbC7Ebb9a88Dd8A554"],
        });
        // Minimal PublicClient stub with just the method we use
        mockPublicClient = { simulateContract: simulateContractMock };
        mockWallet = {
            getAddress: jest.fn().mockReturnValue(MOCK_ADDRESS),
            getNetwork: jest.fn().mockReturnValue({ protocolFamily: "evm" }),
            getPublicClient: jest.fn().mockReturnValue(mockPublicClient),
            sendTransaction: jest.fn().mockResolvedValue("0xmockhash"),
            waitForTransactionReceipt: jest.fn().mockResolvedValue({}),
            readContract: jest.fn(),
            call: jest.fn(),
        };
    });
    describe("create pool", () => {
        it("should successfully create a superfluid pool", async () => {
            const args = {
                superTokenAddress: MOCK_ERC20_CONTRACT,
                chainId: MOCK_CHAIN_ID,
            };
            const config = {
                transferabilityForUnitsOwner: false,
                distributionFromAnyAddress: false,
            };
            const createArgs = [
                MOCK_ERC20_CONTRACT,
                mockWallet.getAddress(),
                config,
            ];
            const data = (0, viem_1.encodeFunctionData)({
                abi: constants_1.GDAv1ForwarderABI,
                functionName: "createPool",
                args: createArgs,
            });
            await actionProvider.createPool(mockWallet, args);
            expect(simulateContractMock).toHaveBeenCalledWith({
                address: constants_1.GDAv1ForwarderAddress,
                abi: constants_1.GDAv1ForwarderABI,
                functionName: "createPool",
                args: createArgs,
                account: MOCK_ADDRESS,
            });
            expect(mockWallet.sendTransaction).toHaveBeenCalledWith({
                to: constants_1.GDAv1ForwarderAddress,
                data,
            });
            expect(mockWallet.waitForTransactionReceipt).toHaveBeenCalledWith("0xmockhash");
        });
        it("should handle pool creation errors", async () => {
            simulateContractMock.mockRejectedValueOnce(new Error("sim failed"));
            const args = {
                superTokenAddress: MOCK_ERC20_CONTRACT,
                chainId: MOCK_CHAIN_ID,
            };
            const response = await actionProvider.createPool(mockWallet, args);
            expect(response).toContain("Error creating Superfluid pool:");
        });
    });
    describe("supportsNetwork", () => {
        it("should return true for Base", () => {
            const result = actionProvider.supportsNetwork({
                protocolFamily: "evm",
                networkId: "base-mainnet",
            });
            expect(result).toBe(true);
        });
        it("should return false for non-base networks", () => {
            const result = actionProvider.supportsNetwork({
                protocolFamily: "bitcoin",
                networkId: "any",
            });
            expect(result).toBe(false);
        });
    });
});
