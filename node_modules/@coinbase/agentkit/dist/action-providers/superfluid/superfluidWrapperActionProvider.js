"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.superfluidWrapperActionProvider = exports.SuperfluidWrapperActionProvider = void 0;
const zod_1 = require("zod");
const schemas_1 = require("./schemas");
const constants_1 = require("./constants");
const viem_1 = require("viem");
const actionProvider_1 = require("../actionProvider");
const wallet_providers_1 = require("../../wallet-providers");
const actionDecorator_1 = require("../actionDecorator");
const viem_2 = require("viem");
/**
 * SuperfluidStreamActionProvider is an action provider for wrapping superfluid token.
 */
class SuperfluidWrapperActionProvider extends actionProvider_1.ActionProvider {
    /**
     * Constructor for the SuperfluidWrapperActionProvider class.
     */
    constructor() {
        super("superfluid-wrap", []);
        /**
         * Checks if the Superfluid action provider supports the given network.
         *
         * @param network - The network to check.
         * @returns True if the Superfluid action provider supports the network, false otherwise.
         */
        this.supportsNetwork = (network) => network.networkId === "base-mainnet" || network.networkId === "base-sepolia";
    }
    /**
     * Wraps a token to a Super token
     * The Super token must already exist
     * If it does not, see SuperfluidCreateSuperTokenAction
     *
     * @param walletProvider - The wallet provider to start the stream from.
     * @param args - The input arguments for the action.
     * @returns A JSON string containing the account details or error message
     */
    async wrapToken(walletProvider, args) {
        try {
            const decimals = await walletProvider.readContract({
                address: args.erc20TokenAddress,
                abi: viem_2.erc20Abi,
                functionName: "decimals",
                args: [],
            });
            const amount = (0, viem_1.parseUnits)(String(args.wrapAmount), Number(decimals));
            const approveData = (0, viem_1.encodeFunctionData)({
                abi: viem_2.erc20Abi,
                functionName: "approve",
                args: [args.superTokenAddress, amount],
            });
            const approveHash = await walletProvider.sendTransaction({
                to: args.erc20TokenAddress,
                data: approveData,
            });
            await walletProvider.waitForTransactionReceipt(approveHash);
            const wrapData = (0, viem_1.encodeFunctionData)({
                abi: constants_1.ISuperTokenAbi,
                functionName: "upgrade",
                args: [amount],
            });
            const wrapHash = await walletProvider.sendTransaction({
                to: args.superTokenAddress,
                data: wrapData,
            });
            await walletProvider.waitForTransactionReceipt(wrapHash);
            return `Wrapped ${args.wrapAmount} of token ${args.erc20TokenAddress} as a SuperToken.  Transaction hash: ${wrapHash}`;
        }
        catch (error) {
            return `Error wrapping Superfluid token: ${error}`;
        }
    }
}
exports.SuperfluidWrapperActionProvider = SuperfluidWrapperActionProvider;
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "wrap_superfluid_token",
        description: `
This tool will directly wrap an amount of ERC20 tokens into its corresponding Super token.
The user must provide the erc20 address, and the super token address.
If this fails, the most likely culprits are:
1. You don't own any of the ERC20 token, or
2. The Super token does not exist.  If it does not exist, suggest the user create the Super token with your SuperTokenCreator action.
        `,
        schema: schemas_1.SuperfluidWrapTokenSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [wallet_providers_1.EvmWalletProvider, void 0]),
    __metadata("design:returntype", Promise)
], SuperfluidWrapperActionProvider.prototype, "wrapToken", null);
const superfluidWrapperActionProvider = () => new SuperfluidWrapperActionProvider();
exports.superfluidWrapperActionProvider = superfluidWrapperActionProvider;
