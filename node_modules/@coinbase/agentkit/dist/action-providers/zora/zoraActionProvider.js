"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ZoraActionProvider_pinataJwt;
Object.defineProperty(exports, "__esModule", { value: true });
exports.zoraActionProvider = exports.ZoraActionProvider = void 0;
const zod_1 = require("zod");
const actionProvider_1 = require("../actionProvider");
const evmWalletProvider_1 = require("../../wallet-providers/evmWalletProvider");
const schemas_1 = require("./schemas");
const actionDecorator_1 = require("../actionDecorator");
const viem_1 = require("viem");
const utils_1 = require("./utils");
const SUPPORTED_NETWORKS = ["base-mainnet", "base-sepolia"];
/**
 * ZoraActionProvider provides actions for interacting with the Zora protocol.
 */
class ZoraActionProvider extends actionProvider_1.ActionProvider {
    /**
     * Constructor for the ZoraActionProvider.
     */
    constructor() {
        super("zora", []);
        _ZoraActionProvider_pinataJwt.set(this, void 0);
        /**
         * Checks if the Zora action provider supports the given network.
         *
         * @param network - The network to check.
         * @returns True if the Zora action provider supports the network, false otherwise.
         */
        this.supportsNetwork = (network) => network.protocolFamily === "evm" && SUPPORTED_NETWORKS.includes(network.networkId);
        // Set Pinata JWT
        const pinataJwt = process.env.PINATA_JWT;
        if (!pinataJwt) {
            throw new Error("PINATA_JWT is not configured. Required for IPFS uploads.");
        }
        __classPrivateFieldSet(this, _ZoraActionProvider_pinataJwt, pinataJwt, "f");
    }
    /**
     * Creates a new Zora coin.
     *
     * @param walletProvider - The wallet provider to use for the transaction.
     * @param args - The input arguments for the action.
     * @returns A message containing the coin creation details.
     */
    async createCoin(walletProvider, args) {
        try {
            // Generate token URI from local file or URI
            const { uri, imageUri } = await (0, utils_1.generateZoraTokenUri)({
                name: args.name,
                symbol: args.symbol,
                description: args.description,
                image: args.image,
                category: args.category,
                pinataConfig: { jwt: __classPrivateFieldGet(this, _ZoraActionProvider_pinataJwt, "f") },
            });
            // Dynamically import Zora SDK
            const { createCoinCall, DeployCurrency, getCoinCreateFromLogs } = await import("@zoralabs/coins-sdk");
            // Create coin call
            const call = {
                name: args.name,
                symbol: args.symbol,
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                uri: uri,
                payoutRecipient: args.payoutRecipient || walletProvider.getAddress(),
                platformReferrer: args.platformReferrer || "0x0000000000000000000000000000000000000000",
                currency: args.currency === "ZORA" ? DeployCurrency.ZORA : DeployCurrency.ETH,
            };
            const createCoinRequest = await createCoinCall(call);
            const { abi, functionName, address, args: callArgs, value } = createCoinRequest;
            const data = (0, viem_1.encodeFunctionData)({ abi, functionName, args: callArgs });
            const txRequest = { to: address, data, value };
            // Send transaction
            const hash = await walletProvider.sendTransaction(txRequest);
            const receipt = await walletProvider.waitForTransactionReceipt(hash);
            const deployment = getCoinCreateFromLogs(receipt);
            if (receipt.status === "success") {
                return JSON.stringify({
                    success: true,
                    transactionHash: hash,
                    coinAddress: deployment?.coin,
                    imageUri,
                    uri,
                    deployment,
                    ...(walletProvider.getNetwork().networkId === "base-mainnet" &&
                        deployment?.coin && {
                        zoraURL: `https://zora.co/coin/base:${deployment.coin}`,
                    }),
                });
            }
            else {
                throw new Error("Coin creation transaction reverted");
            }
        }
        catch (error) {
            return JSON.stringify({
                success: false,
                error: error instanceof Error ? error.message : String(error),
            });
        }
    }
}
exports.ZoraActionProvider = ZoraActionProvider;
_ZoraActionProvider_pinataJwt = new WeakMap();
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "coinIt",
        description: `
This tool will create a new Zora coin.
It takes the following parameters:
- name: The name of the coin
- symbol: The symbol of the coin
- image: Local image file path or URI (ipfs:// or https://)
- description: The description of the coin
- payoutRecipient: The address that will receive creator earnings (optional, defaults to the wallet address)
- platformReferrer: The address that will receive platform referrer fees (optional, defaults to 0x0000000000000000000000000000000000000000)
- category: The category of the coin (optional, defaults to 'social')
- currency: The currency for deployment, can be 'ZORA' or 'ETH'. Determines which token will be used for the trading pair (optional, defaults to 'ZORA').
The action will return the transaction hash, coin address, and deployment details upon success.
`,
        schema: schemas_1.CreateCoinSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [evmWalletProvider_1.EvmWalletProvider, void 0]),
    __metadata("design:returntype", Promise)
], ZoraActionProvider.prototype, "createCoin", null);
/**
 * Factory function to create a new ZoraActionProvider instance.
 *
 * @returns A new ZoraActionProvider instance
 */
const zoraActionProvider = () => new ZoraActionProvider();
exports.zoraActionProvider = zoraActionProvider;
