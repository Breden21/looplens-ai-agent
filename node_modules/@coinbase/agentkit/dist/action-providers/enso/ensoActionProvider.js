"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensoActionProvider = exports.EnsoActionProvider = void 0;
const zod_1 = require("zod");
const actionProvider_1 = require("../actionProvider");
const actionDecorator_1 = require("../actionDecorator");
const schemas_1 = require("./schemas");
const viem_1 = require("viem");
const wallet_providers_1 = require("../../wallet-providers");
const constants_1 = require("./constants");
const sdk_1 = require("@ensofinance/sdk");
/**
 * EnsoActionProvider is an action provider for Enso.
 */
class EnsoActionProvider extends actionProvider_1.ActionProvider {
    /**
     * Constructor for the EnsoActionProvider
     *
     * @param params - The initialization parameters for the Enso action provider
     */
    constructor(params = {}) {
        super("enso", []);
        /**
         * Checks if the Enso action provider supports the given network.
         *
         * @param network - The network to check.
         * @returns True if the Enso action provider supports the network, false otherwise.
         */
        this.supportsNetwork = (network) => {
            const chainIdCheck = network.chainId && constants_1.ENSO_SUPPORTED_NETWORKS.has(Number(network.chainId));
            return Boolean(chainIdCheck);
        };
        this.ensoClient = new sdk_1.EnsoClient({ apiKey: params.apiKey || constants_1.ENSO_API_KEY });
    }
    /**
     * Finds the optimal route from a token to a token and executes it.
     *
     * @param walletProvider - The wallet to execute the transaction from.
     * @param args - The input arguments for the action.
     * @returns A message containing the token route details.
     */
    async route(walletProvider, args) {
        try {
            const chainId = Number(walletProvider.getNetwork().chainId);
            if (!chainId || !constants_1.ENSO_SUPPORTED_NETWORKS.has(chainId)) {
                return `Network ${chainId} is not supported by Enso`;
            }
            const fromAddress = (0, viem_1.getAddress)(walletProvider.getAddress());
            const tokenIn = (0, viem_1.getAddress)(args.tokenIn);
            const tokenOut = (0, viem_1.getAddress)(args.tokenOut);
            const tokenInResponse = await this.ensoClient.getTokenData({
                address: tokenIn,
                chainId,
            });
            if (tokenInResponse.data.length !== 1) {
                throw `Could not find data for provided tokenIn`;
            }
            const tokenInData = tokenInResponse.data[0];
            const amountIn = (0, viem_1.parseUnits)(args.amountIn, tokenInData.decimals).toString();
            const params = {
                chainId,
                tokenIn: [tokenIn],
                tokenOut: [tokenOut],
                amountIn: [amountIn],
                routingStrategy: "router",
                fromAddress,
                receiver: fromAddress,
                spender: fromAddress,
            };
            if (args.slippage) {
                params.slippage = args.slippage;
            }
            const routeData = await this.ensoClient.getRouteData(params);
            if (!routeData.tx.data.startsWith(constants_1.ENSO_ROUTE_SINGLE_SIG)) {
                return `Unsupported calldata returned from Enso API`;
            }
            // If the tokenIn is ERC20, do approve
            if (args.tokenIn.toLowerCase() !== constants_1.ENSO_ETH.toLowerCase()) {
                const approval = await this.ensoClient.getApprovalData({
                    chainId,
                    amount: amountIn,
                    fromAddress,
                    tokenAddress: (0, viem_1.getAddress)(args.tokenIn),
                });
                const hash = await walletProvider.sendTransaction({
                    to: approval.tx.to,
                    data: approval.tx.data,
                });
                await walletProvider.waitForTransactionReceipt(hash);
            }
            const hash = await walletProvider.sendTransaction({
                to: routeData.tx.to,
                value: BigInt(routeData.tx.value),
                data: routeData.tx.data,
            });
            await walletProvider.waitForTransactionReceipt(hash);
            return `Route executed successfully, transaction hash: ${hash}`;
        }
        catch (error) {
            return `Error routing token through Enso: ${error}`;
        }
    }
}
exports.EnsoActionProvider = EnsoActionProvider;
__decorate([
    (0, actionDecorator_1.CreateAction)({
        name: "route",
        description: `This tool will find the optimal route for entering or exiting any DeFi position or swapping any ERC20 tokens.`,
        schema: schemas_1.EnsoRouteSchema,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [wallet_providers_1.EvmWalletProvider, void 0]),
    __metadata("design:returntype", Promise)
], EnsoActionProvider.prototype, "route", null);
const ensoActionProvider = () => new EnsoActionProvider();
exports.ensoActionProvider = ensoActionProvider;
