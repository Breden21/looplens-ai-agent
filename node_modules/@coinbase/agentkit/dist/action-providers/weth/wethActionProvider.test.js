"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schemas_1 = require("./schemas");
const viem_1 = require("viem");
const constants_1 = require("./constants");
const wethActionProvider_1 = require("./wethActionProvider");
const MOCK_AMOUNT = "15";
const MOCK_ADDRESS = "0x1234567890123456789012345678901234543210";
describe("Wrap Eth Schema", () => {
    it("should successfully parse valid input", () => {
        const validInput = {
            amountToWrap: MOCK_AMOUNT,
        };
        const result = schemas_1.WrapEthSchema.safeParse(validInput);
        expect(result.success).toBe(true);
        expect(result.data).toEqual(validInput);
    });
    it("should fail parsing empty input", () => {
        const emptyInput = {};
        const result = schemas_1.WrapEthSchema.safeParse(emptyInput);
        expect(result.success).toBe(false);
    });
});
describe("Unwrap Eth Schema", () => {
    it("should successfully parse valid input", () => {
        const validInput = {
            amountToUnwrap: MOCK_AMOUNT,
        };
        const result = schemas_1.UnwrapEthSchema.safeParse(validInput);
        expect(result.success).toBe(true);
        expect(result.data).toEqual(validInput);
    });
    it("should fail parsing empty input", () => {
        const emptyInput = {};
        const result = schemas_1.UnwrapEthSchema.safeParse(emptyInput);
        expect(result.success).toBe(false);
    });
});
describe("Wrap Eth Action", () => {
    let mockWallet;
    const actionProvider = (0, wethActionProvider_1.wethActionProvider)();
    beforeEach(async () => {
        mockWallet = {
            getAddress: jest.fn().mockReturnValue(MOCK_ADDRESS),
            getNetwork: jest.fn().mockReturnValue({
                protocolFamily: "evm",
                networkId: "base-mainnet",
            }),
            getBalance: jest.fn().mockResolvedValue((0, viem_1.parseUnits)("20", 18)), // 20 ETH balance
            sendTransaction: jest.fn(),
            waitForTransactionReceipt: jest.fn(),
        };
    });
    it("should successfully respond", async () => {
        const args = {
            amountToWrap: MOCK_AMOUNT,
        };
        const hash = "0x1234567890123456789012345678901234567890";
        mockWallet.sendTransaction.mockResolvedValue(hash);
        const response = await actionProvider.wrapEth(mockWallet, args);
        expect(mockWallet.sendTransaction).toHaveBeenCalledWith({
            to: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            data: (0, viem_1.encodeFunctionData)({
                abi: constants_1.WETH_ABI,
                functionName: "deposit",
            }),
            value: (0, viem_1.parseUnits)(MOCK_AMOUNT, 18),
        });
        expect(response).toContain(`Wrapped ${MOCK_AMOUNT} ETH to WETH. Transaction hash: ${hash}`);
    });
    it("should fail with an error", async () => {
        const args = {
            amountToWrap: MOCK_AMOUNT,
        };
        const error = new Error("Failed to wrap ETH");
        mockWallet.sendTransaction.mockRejectedValue(error);
        const response = await actionProvider.wrapEth(mockWallet, args);
        expect(mockWallet.sendTransaction).toHaveBeenCalledWith({
            to: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            data: (0, viem_1.encodeFunctionData)({
                abi: constants_1.WETH_ABI,
                functionName: "deposit",
            }),
            value: (0, viem_1.parseUnits)(MOCK_AMOUNT, 18),
        });
        expect(response).toContain(`Error wrapping ETH: ${error}`);
    });
    it("should fail with insufficient ETH balance", async () => {
        const args = {
            amountToWrap: MOCK_AMOUNT,
        };
        // Mock insufficient balance (less than 15 ETH)
        mockWallet.getBalance.mockResolvedValue((0, viem_1.parseUnits)("10", 18));
        const response = await actionProvider.wrapEth(mockWallet, args);
        expect(mockWallet.sendTransaction).not.toHaveBeenCalled();
        expect(response).toContain("Error: Insufficient ETH balance");
    });
});
describe("Unwrap Eth Action", () => {
    let mockWallet;
    const actionProvider = (0, wethActionProvider_1.wethActionProvider)();
    beforeEach(async () => {
        mockWallet = {
            getAddress: jest.fn().mockReturnValue(MOCK_ADDRESS),
            getNetwork: jest.fn().mockReturnValue({
                protocolFamily: "evm",
                networkId: "base-mainnet",
            }),
            readContract: jest.fn().mockResolvedValue((0, viem_1.parseUnits)("20", 18)), // 20 WETH balance
            sendTransaction: jest.fn(),
            waitForTransactionReceipt: jest.fn(),
        };
    });
    it("should successfully respond", async () => {
        const args = {
            amountToUnwrap: MOCK_AMOUNT,
        };
        const hash = "0x1234567890123456789012345678901234567890";
        mockWallet.sendTransaction.mockResolvedValue(hash);
        const response = await actionProvider.unwrapEth(mockWallet, args);
        expect(mockWallet.readContract).toHaveBeenCalledWith({
            address: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            abi: viem_1.erc20Abi,
            functionName: "balanceOf",
            args: [MOCK_ADDRESS],
        });
        expect(mockWallet.sendTransaction).toHaveBeenCalledWith({
            to: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            data: (0, viem_1.encodeFunctionData)({
                abi: constants_1.WETH_ABI,
                functionName: "withdraw",
                args: [(0, viem_1.parseUnits)(MOCK_AMOUNT, 18)],
            }),
        });
        expect(response).toContain(`Unwrapped ${MOCK_AMOUNT} WETH to ETH. Transaction hash: ${hash}`);
    });
    it("should fail with an error", async () => {
        const args = {
            amountToUnwrap: MOCK_AMOUNT,
        };
        const error = new Error("Failed to unwrap WETH");
        mockWallet.sendTransaction.mockRejectedValue(error);
        const response = await actionProvider.unwrapEth(mockWallet, args);
        expect(mockWallet.readContract).toHaveBeenCalledWith({
            address: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            abi: viem_1.erc20Abi,
            functionName: "balanceOf",
            args: [MOCK_ADDRESS],
        });
        expect(mockWallet.sendTransaction).toHaveBeenCalledWith({
            to: (0, wethActionProvider_1.getWethAddress)({ protocolFamily: "evm", networkId: "base-mainnet" }),
            data: (0, viem_1.encodeFunctionData)({
                abi: constants_1.WETH_ABI,
                functionName: "withdraw",
                args: [(0, viem_1.parseUnits)(MOCK_AMOUNT, 18)],
            }),
        });
        expect(response).toContain(`Error unwrapping WETH: ${error}`);
    });
    it("should fail with insufficient WETH balance", async () => {
        const args = {
            amountToUnwrap: MOCK_AMOUNT,
        };
        // Mock insufficient WETH balance (less than 15 WETH)
        mockWallet.readContract.mockResolvedValue((0, viem_1.parseUnits)("10", 18));
        const response = await actionProvider.unwrapEth(mockWallet, args);
        expect(mockWallet.sendTransaction).not.toHaveBeenCalled();
        expect(response).toContain("Error: Insufficient WETH balance");
    });
});
describe("supportsNetwork", () => {
    const actionProvider = (0, wethActionProvider_1.wethActionProvider)();
    it("should return true for base-mainnet", () => {
        const result = actionProvider.supportsNetwork({
            protocolFamily: "evm",
            networkId: "base-mainnet",
        });
        expect(result).toBe(true);
    });
    it("should return true for base-sepolia", () => {
        const result = actionProvider.supportsNetwork({
            protocolFamily: "evm",
            networkId: "base-sepolia",
        });
        expect(result).toBe(true);
    });
    it("should return true for ethereum-mainnet", () => {
        const result = actionProvider.supportsNetwork({
            protocolFamily: "evm",
            networkId: "ethereum-mainnet",
        });
        expect(result).toBe(true);
    });
    it("should return false for networks without WETH", () => {
        const result = actionProvider.supportsNetwork({
            protocolFamily: "evm",
            networkId: "polygon-mainnet",
        });
        expect(result).toBe(false);
    });
});
