"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getX402Network = getX402Network;
exports.handleHttpError = handleHttpError;
exports.formatPaymentOption = formatPaymentOption;
exports.isUsdcAsset = isUsdcAsset;
exports.convertWholeUnitsToAtomic = convertWholeUnitsToAtomic;
const utils_1 = require("../erc20/utils");
const constants_1 = require("../erc20/constants");
const viem_1 = require("viem");
const wallet_providers_1 = require("../../wallet-providers");
/**
 * USDC token addresses for Solana networks
 */
const SOLANA_USDC_ADDRESSES = {
    "solana-devnet": "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU",
    "solana-mainnet": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
};
/**
 * Converts the internal network ID to the format expected by the x402 protocol.
 *
 * @param network - The network to convert
 * @returns The network ID in x402 format
 * @throws Error if the network is not supported
 */
function getX402Network(network) {
    switch (network.networkId) {
        case "base-mainnet":
            return "base";
        case "base-sepolia":
            return "base-sepolia";
        case "solana-mainnet":
            return "solana";
        case "solana-devnet":
            return "solana-devnet";
        default:
            return network.networkId;
    }
}
/**
 * Helper method to handle HTTP errors consistently.
 *
 * @param error - The axios error to handle
 * @param url - The URL that was being accessed when the error occurred
 * @returns A JSON string containing formatted error details
 */
function handleHttpError(error, url) {
    if (error.response) {
        return JSON.stringify({
            error: true,
            message: `HTTP ${error.response.status} error when accessing ${url}`,
            details: error.response.data?.error || error.response.statusText,
            suggestion: "Check if the URL is correct and the API is available.",
        }, null, 2);
    }
    if (error.request) {
        return JSON.stringify({
            error: true,
            message: `Network error when accessing ${url}`,
            details: error.message,
            suggestion: "Check your internet connection and verify the API endpoint is accessible.",
        }, null, 2);
    }
    return JSON.stringify({
        error: true,
        message: `Error making request to ${url}`,
        details: error.message,
        suggestion: "Please check the request parameters and try again.",
    }, null, 2);
}
/**
 * Formats a payment option into a human-readable string.
 *
 * @param option - The payment option to format
 * @param option.asset - The asset address or identifier
 * @param option.maxAmountRequired - The maximum amount required for the payment
 * @param option.network - The network identifier
 * @param walletProvider - The wallet provider for token details lookup
 * @returns A formatted string like "0.1 USDC on base"
 */
async function formatPaymentOption(option, walletProvider) {
    const { asset, maxAmountRequired, network } = option;
    // Check if this is an EVM network and we can use ERC20 helpers
    const walletNetwork = walletProvider.getNetwork();
    const isEvmNetwork = walletNetwork.protocolFamily === "evm";
    const isSvmNetwork = walletNetwork.protocolFamily === "svm";
    if (isEvmNetwork && walletProvider instanceof wallet_providers_1.EvmWalletProvider) {
        const networkId = walletNetwork.networkId;
        const tokenSymbols = constants_1.TOKEN_ADDRESSES_BY_SYMBOLS[networkId];
        if (tokenSymbols) {
            for (const [symbol, address] of Object.entries(tokenSymbols)) {
                if (asset.toLowerCase() === address.toLowerCase()) {
                    const decimals = symbol === "USDC" || symbol === "EURC" ? 6 : 18;
                    const formattedAmount = (0, viem_1.formatUnits)(BigInt(maxAmountRequired), decimals);
                    return `${formattedAmount} ${symbol} on ${network} network`;
                }
            }
        }
        // Fall back to getTokenDetails for unknown tokens
        try {
            const tokenDetails = await (0, utils_1.getTokenDetails)(walletProvider, asset);
            if (tokenDetails) {
                const formattedAmount = (0, viem_1.formatUnits)(BigInt(maxAmountRequired), tokenDetails.decimals);
                return `${formattedAmount} ${tokenDetails.name} on ${network} network`;
            }
        }
        catch {
            // If we can't get token details, fall back to raw format
        }
    }
    if (isSvmNetwork && walletProvider instanceof wallet_providers_1.SvmWalletProvider) {
        // Check if the asset is USDC on Solana networks
        const networkId = walletNetwork.networkId;
        const usdcAddress = SOLANA_USDC_ADDRESSES[networkId];
        if (usdcAddress && asset === usdcAddress) {
            // USDC has 6 decimals on Solana
            const formattedAmount = (0, viem_1.formatUnits)(BigInt(maxAmountRequired), 6);
            return `${formattedAmount} USDC on ${network} network`;
        }
    }
    // Fallback to original format for non-EVM/SVM networks or when token details can't be fetched
    return `${asset} ${maxAmountRequired} on ${network} network`;
}
/**
 * Checks if an asset is USDC on any supported network.
 *
 * @param asset - The asset address or identifier
 * @param walletProvider - The wallet provider for network context
 * @returns True if the asset is USDC, false otherwise
 */
function isUsdcAsset(asset, walletProvider) {
    const walletNetwork = walletProvider.getNetwork();
    const isEvmNetwork = walletNetwork.protocolFamily === "evm";
    const isSvmNetwork = walletNetwork.protocolFamily === "svm";
    if (isEvmNetwork && walletProvider instanceof wallet_providers_1.EvmWalletProvider) {
        const networkId = walletNetwork.networkId;
        const tokenSymbols = constants_1.TOKEN_ADDRESSES_BY_SYMBOLS[networkId];
        if (tokenSymbols && tokenSymbols.USDC) {
            return asset.toLowerCase() === tokenSymbols.USDC.toLowerCase();
        }
    }
    if (isSvmNetwork && walletProvider instanceof wallet_providers_1.SvmWalletProvider) {
        const networkId = walletNetwork.networkId;
        const usdcAddress = SOLANA_USDC_ADDRESSES[networkId];
        if (usdcAddress) {
            return asset === usdcAddress;
        }
    }
    return false;
}
/**
 * Converts whole units to atomic units for a given asset.
 *
 * @param wholeUnits - The amount in whole units (e.g., 0.1 for 0.1 USDC)
 * @param asset - The asset address or identifier
 * @param walletProvider - The wallet provider for token details lookup
 * @returns The amount in atomic units as a string, or null if conversion fails
 */
async function convertWholeUnitsToAtomic(wholeUnits, asset, walletProvider) {
    // Check if this is an EVM network and we can use ERC20 helpers
    const walletNetwork = walletProvider.getNetwork();
    const isEvmNetwork = walletNetwork.protocolFamily === "evm";
    const isSvmNetwork = walletNetwork.protocolFamily === "svm";
    if (isEvmNetwork && walletProvider instanceof wallet_providers_1.EvmWalletProvider) {
        const networkId = walletNetwork.networkId;
        const tokenSymbols = constants_1.TOKEN_ADDRESSES_BY_SYMBOLS[networkId];
        if (tokenSymbols) {
            for (const [symbol, address] of Object.entries(tokenSymbols)) {
                if (asset.toLowerCase() === address.toLowerCase()) {
                    const decimals = symbol === "USDC" || symbol === "EURC" ? 6 : 18;
                    return (0, viem_1.parseUnits)(wholeUnits.toString(), decimals).toString();
                }
            }
        }
        // Fall back to getTokenDetails for unknown tokens
        try {
            const tokenDetails = await (0, utils_1.getTokenDetails)(walletProvider, asset);
            if (tokenDetails) {
                return (0, viem_1.parseUnits)(wholeUnits.toString(), tokenDetails.decimals).toString();
            }
        }
        catch {
            // If we can't get token details, fall back to assuming 18 decimals
        }
    }
    if (isSvmNetwork && walletProvider instanceof wallet_providers_1.SvmWalletProvider) {
        // Check if the asset is USDC on Solana networks
        const networkId = walletNetwork.networkId;
        const usdcAddress = SOLANA_USDC_ADDRESSES[networkId];
        if (usdcAddress && asset === usdcAddress) {
            // USDC has 6 decimals on Solana
            return (0, viem_1.parseUnits)(wholeUnits.toString(), 6).toString();
        }
    }
    // Fallback to 18 decimals for unknown tokens or non-EVM/SVM networks
    return (0, viem_1.parseUnits)(wholeUnits.toString(), 18).toString();
}
